Attachment.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Attachment message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * //// Attachments (parse errors, execution errors, screenshots, links...)
 * 
 * An attachment represents any kind of data associated with a line in a
 * [Source](#io.cucumber.messages.Source) file. It can be used for:
 * 
 * * Syntax errors during parse time
 * * Screenshots captured and attached during execution
 * * Logs captured and attached during execution
 * 
 * It is not to be used for runtime errors raised/thrown during execution. This
 * is captured in `TestResult`. */
final class Attachment implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Attachment with all properties
     *
     */
    public function __construct(

        /**
         * The body of the attachment. If `contentEncoding` is `IDENTITY`, the attachment
         * is simply the string. If it's `BASE64`, the string should be Base64 decoded to
         * obtain the attachment.
         */
        public readonly string $body = '',

        /**
         * Whether to interpret `body` "as-is" (IDENTITY) or if it needs to be Base64-decoded (BASE64).
         * 
         * Content encoding is *not* determined by the media type, but rather by the type
         * of the object being attached:
         * 
         * - string => IDENTITY
         * - byte array => BASE64
         * - stream => BASE64
         */
        public readonly Attachment\ContentEncoding $contentEncoding = Attachment\ContentEncoding::IDENTITY,

        /**
         * Suggested file name of the attachment. (Provided by the user as an argument to `attach`)
         */
        public readonly ?string $fileName = null,

        /**
         * The media type of the data. This can be any valid
         * [IANA Media Type](https://www.iana.org/assignments/media-types/media-types.xhtml)
         * as well as Cucumber-specific media types such as `text/x.cucumber.gherkin+plain`
         * and `text/x.cucumber.stacktrace+plain`
         */
        public readonly string $mediaType = '',

        public readonly ?Source $source = null,

        public readonly ?string $testCaseStartedId = null,

        public readonly ?string $testStepId = null,

        /**
         * A URL where the attachment can be retrieved. This field should not be set by Cucumber.
         * It should be set by a program that reads a message stream and does the following for
         * each Attachment message:
         * 
         * - Writes the body (after base64 decoding if necessary) to a new file.
         * - Sets `body` and `contentEncoding` to `null`
         * - Writes out the new attachment message
         * 
         * This will result in a smaller message stream, which can improve performance and
         * reduce bandwidth of message consumers. It also makes it easier to process and download attachments
         * separately from reports.
         */
        public readonly ?string $url = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureBody($arr);
        self::ensureContentEncoding($arr);
        self::ensureFileName($arr);
        self::ensureMediaType($arr);
        self::ensureSource($arr);
        self::ensureTestCaseStartedId($arr);
        self::ensureTestStepId($arr);
        self::ensureUrl($arr);

        return new self(
            (string) $arr['body'],
            Attachment\ContentEncoding::from((string) $arr['contentEncoding']),
            isset($arr['fileName']) ? (string) $arr['fileName'] : null,
            (string) $arr['mediaType'],
            isset($arr['source']) ? Source::fromArray($arr['source']) : null,
            isset($arr['testCaseStartedId']) ? (string) $arr['testCaseStartedId'] : null,
            isset($arr['testStepId']) ? (string) $arr['testStepId'] : null,
            isset($arr['url']) ? (string) $arr['url'] : null,
        );
    }

    /**
     * @psalm-assert array{body: string|int|bool} $arr
     */
    private static function ensureBody(array $arr): void
    {
        if (!array_key_exists('body', $arr)) {
            throw new SchemaViolationException('Property \'body\' is required but was not found');
        }
        if (array_key_exists('body', $arr) && is_array($arr['body'])) {
            throw new SchemaViolationException('Property \'body\' was array');
        }
    }

    /**
     * @psalm-assert array{contentEncoding: string|int|bool} $arr
     */
    private static function ensureContentEncoding(array $arr): void
    {
        if (!array_key_exists('contentEncoding', $arr)) {
            throw new SchemaViolationException('Property \'contentEncoding\' is required but was not found');
        }
        if (array_key_exists('contentEncoding', $arr) && is_array($arr['contentEncoding'])) {
            throw new SchemaViolationException('Property \'contentEncoding\' was array');
        }
    }

    /**
     * @psalm-assert array{fileName?: string|int|bool} $arr
     */
    private static function ensureFileName(array $arr): void
    {
        if (array_key_exists('fileName', $arr) && is_array($arr['fileName'])) {
            throw new SchemaViolationException('Property \'fileName\' was array');
        }
    }

    /**
     * @psalm-assert array{mediaType: string|int|bool} $arr
     */
    private static function ensureMediaType(array $arr): void
    {
        if (!array_key_exists('mediaType', $arr)) {
            throw new SchemaViolationException('Property \'mediaType\' is required but was not found');
        }
        if (array_key_exists('mediaType', $arr) && is_array($arr['mediaType'])) {
            throw new SchemaViolationException('Property \'mediaType\' was array');
        }
    }

    /**
     * @psalm-assert array{source?: array} $arr
     */
    private static function ensureSource(array $arr): void
    {
        if (array_key_exists('source', $arr) && !is_array($arr['source'])) {
            throw new SchemaViolationException('Property \'source\' was not array');
        }
    }

    /**
     * @psalm-assert array{testCaseStartedId?: string|int|bool} $arr
     */
    private static function ensureTestCaseStartedId(array $arr): void
    {
        if (array_key_exists('testCaseStartedId', $arr) && is_array($arr['testCaseStartedId'])) {
            throw new SchemaViolationException('Property \'testCaseStartedId\' was array');
        }
    }

    /**
     * @psalm-assert array{testStepId?: string|int|bool} $arr
     */
    private static function ensureTestStepId(array $arr): void
    {
        if (array_key_exists('testStepId', $arr) && is_array($arr['testStepId'])) {
            throw new SchemaViolationException('Property \'testStepId\' was array');
        }
    }

    /**
     * @psalm-assert array{url?: string|int|bool} $arr
     */
    private static function ensureUrl(array $arr): void
    {
        if (array_key_exists('url', $arr) && is_array($arr['url'])) {
            throw new SchemaViolationException('Property \'url\' was array');
        }
    }
}

Duration.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Duration message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * The structure is pretty close of the Timestamp one. For clarity, a second type
 * of message is used. */
final class Duration implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Duration with all properties
     *
     */
    public function __construct(

        public readonly int $seconds = 0,

        /**
         * Non-negative fractions of a second at nanosecond resolution. Negative
         * second values with fractions must still have non-negative nanos values
         * that count forward in time. Must be from 0 to 999,999,999
         * inclusive.
         */
        public readonly int $nanos = 0,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureSeconds($arr);
        self::ensureNanos($arr);

        return new self(
            (int) $arr['seconds'],
            (int) $arr['nanos'],
        );
    }

    /**
     * @psalm-assert array{seconds: string|int|bool} $arr
     */
    private static function ensureSeconds(array $arr): void
    {
        if (!array_key_exists('seconds', $arr)) {
            throw new SchemaViolationException('Property \'seconds\' is required but was not found');
        }
        if (array_key_exists('seconds', $arr) && is_array($arr['seconds'])) {
            throw new SchemaViolationException('Property \'seconds\' was array');
        }
    }

    /**
     * @psalm-assert array{nanos: string|int|bool} $arr
     */
    private static function ensureNanos(array $arr): void
    {
        if (!array_key_exists('nanos', $arr)) {
            throw new SchemaViolationException('Property \'nanos\' is required but was not found');
        }
        if (array_key_exists('nanos', $arr) && is_array($arr['nanos'])) {
            throw new SchemaViolationException('Property \'nanos\' was array');
        }
    }
}

Envelope.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Envelope message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * When removing a field, replace it with reserved, rather than deleting the line.
 * When adding a field, add it to the end and increment the number by one.
 * See https://developers.google.com/protocol-buffers/docs/proto#updating for details
 * 
 * All the messages that are passed between different components/processes are Envelope
 * messages. */
final class Envelope implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Envelope with all properties
     *
     */
    public function __construct(

        public readonly ?Attachment $attachment = null,

        public readonly ?GherkinDocument $gherkinDocument = null,

        public readonly ?Hook $hook = null,

        public readonly ?Meta $meta = null,

        public readonly ?ParameterType $parameterType = null,

        public readonly ?ParseError $parseError = null,

        public readonly ?Pickle $pickle = null,

        public readonly ?Source $source = null,

        public readonly ?StepDefinition $stepDefinition = null,

        public readonly ?TestCase $testCase = null,

        public readonly ?TestCaseFinished $testCaseFinished = null,

        public readonly ?TestCaseStarted $testCaseStarted = null,

        public readonly ?TestRunFinished $testRunFinished = null,

        public readonly ?TestRunStarted $testRunStarted = null,

        public readonly ?TestStepFinished $testStepFinished = null,

        public readonly ?TestStepStarted $testStepStarted = null,

        public readonly ?UndefinedParameterType $undefinedParameterType = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureAttachment($arr);
        self::ensureGherkinDocument($arr);
        self::ensureHook($arr);
        self::ensureMeta($arr);
        self::ensureParameterType($arr);
        self::ensureParseError($arr);
        self::ensurePickle($arr);
        self::ensureSource($arr);
        self::ensureStepDefinition($arr);
        self::ensureTestCase($arr);
        self::ensureTestCaseFinished($arr);
        self::ensureTestCaseStarted($arr);
        self::ensureTestRunFinished($arr);
        self::ensureTestRunStarted($arr);
        self::ensureTestStepFinished($arr);
        self::ensureTestStepStarted($arr);
        self::ensureUndefinedParameterType($arr);

        return new self(
            isset($arr['attachment']) ? Attachment::fromArray($arr['attachment']) : null,
            isset($arr['gherkinDocument']) ? GherkinDocument::fromArray($arr['gherkinDocument']) : null,
            isset($arr['hook']) ? Hook::fromArray($arr['hook']) : null,
            isset($arr['meta']) ? Meta::fromArray($arr['meta']) : null,
            isset($arr['parameterType']) ? ParameterType::fromArray($arr['parameterType']) : null,
            isset($arr['parseError']) ? ParseError::fromArray($arr['parseError']) : null,
            isset($arr['pickle']) ? Pickle::fromArray($arr['pickle']) : null,
            isset($arr['source']) ? Source::fromArray($arr['source']) : null,
            isset($arr['stepDefinition']) ? StepDefinition::fromArray($arr['stepDefinition']) : null,
            isset($arr['testCase']) ? TestCase::fromArray($arr['testCase']) : null,
            isset($arr['testCaseFinished']) ? TestCaseFinished::fromArray($arr['testCaseFinished']) : null,
            isset($arr['testCaseStarted']) ? TestCaseStarted::fromArray($arr['testCaseStarted']) : null,
            isset($arr['testRunFinished']) ? TestRunFinished::fromArray($arr['testRunFinished']) : null,
            isset($arr['testRunStarted']) ? TestRunStarted::fromArray($arr['testRunStarted']) : null,
            isset($arr['testStepFinished']) ? TestStepFinished::fromArray($arr['testStepFinished']) : null,
            isset($arr['testStepStarted']) ? TestStepStarted::fromArray($arr['testStepStarted']) : null,
            isset($arr['undefinedParameterType']) ? UndefinedParameterType::fromArray($arr['undefinedParameterType']) : null,
        );
    }

    /**
     * @psalm-assert array{attachment?: array} $arr
     */
    private static function ensureAttachment(array $arr): void
    {
        if (array_key_exists('attachment', $arr) && !is_array($arr['attachment'])) {
            throw new SchemaViolationException('Property \'attachment\' was not array');
        }
    }

    /**
     * @psalm-assert array{gherkinDocument?: array} $arr
     */
    private static function ensureGherkinDocument(array $arr): void
    {
        if (array_key_exists('gherkinDocument', $arr) && !is_array($arr['gherkinDocument'])) {
            throw new SchemaViolationException('Property \'gherkinDocument\' was not array');
        }
    }

    /**
     * @psalm-assert array{hook?: array} $arr
     */
    private static function ensureHook(array $arr): void
    {
        if (array_key_exists('hook', $arr) && !is_array($arr['hook'])) {
            throw new SchemaViolationException('Property \'hook\' was not array');
        }
    }

    /**
     * @psalm-assert array{meta?: array} $arr
     */
    private static function ensureMeta(array $arr): void
    {
        if (array_key_exists('meta', $arr) && !is_array($arr['meta'])) {
            throw new SchemaViolationException('Property \'meta\' was not array');
        }
    }

    /**
     * @psalm-assert array{parameterType?: array} $arr
     */
    private static function ensureParameterType(array $arr): void
    {
        if (array_key_exists('parameterType', $arr) && !is_array($arr['parameterType'])) {
            throw new SchemaViolationException('Property \'parameterType\' was not array');
        }
    }

    /**
     * @psalm-assert array{parseError?: array} $arr
     */
    private static function ensureParseError(array $arr): void
    {
        if (array_key_exists('parseError', $arr) && !is_array($arr['parseError'])) {
            throw new SchemaViolationException('Property \'parseError\' was not array');
        }
    }

    /**
     * @psalm-assert array{pickle?: array} $arr
     */
    private static function ensurePickle(array $arr): void
    {
        if (array_key_exists('pickle', $arr) && !is_array($arr['pickle'])) {
            throw new SchemaViolationException('Property \'pickle\' was not array');
        }
    }

    /**
     * @psalm-assert array{source?: array} $arr
     */
    private static function ensureSource(array $arr): void
    {
        if (array_key_exists('source', $arr) && !is_array($arr['source'])) {
            throw new SchemaViolationException('Property \'source\' was not array');
        }
    }

    /**
     * @psalm-assert array{stepDefinition?: array} $arr
     */
    private static function ensureStepDefinition(array $arr): void
    {
        if (array_key_exists('stepDefinition', $arr) && !is_array($arr['stepDefinition'])) {
            throw new SchemaViolationException('Property \'stepDefinition\' was not array');
        }
    }

    /**
     * @psalm-assert array{testCase?: array} $arr
     */
    private static function ensureTestCase(array $arr): void
    {
        if (array_key_exists('testCase', $arr) && !is_array($arr['testCase'])) {
            throw new SchemaViolationException('Property \'testCase\' was not array');
        }
    }

    /**
     * @psalm-assert array{testCaseFinished?: array} $arr
     */
    private static function ensureTestCaseFinished(array $arr): void
    {
        if (array_key_exists('testCaseFinished', $arr) && !is_array($arr['testCaseFinished'])) {
            throw new SchemaViolationException('Property \'testCaseFinished\' was not array');
        }
    }

    /**
     * @psalm-assert array{testCaseStarted?: array} $arr
     */
    private static function ensureTestCaseStarted(array $arr): void
    {
        if (array_key_exists('testCaseStarted', $arr) && !is_array($arr['testCaseStarted'])) {
            throw new SchemaViolationException('Property \'testCaseStarted\' was not array');
        }
    }

    /**
     * @psalm-assert array{testRunFinished?: array} $arr
     */
    private static function ensureTestRunFinished(array $arr): void
    {
        if (array_key_exists('testRunFinished', $arr) && !is_array($arr['testRunFinished'])) {
            throw new SchemaViolationException('Property \'testRunFinished\' was not array');
        }
    }

    /**
     * @psalm-assert array{testRunStarted?: array} $arr
     */
    private static function ensureTestRunStarted(array $arr): void
    {
        if (array_key_exists('testRunStarted', $arr) && !is_array($arr['testRunStarted'])) {
            throw new SchemaViolationException('Property \'testRunStarted\' was not array');
        }
    }

    /**
     * @psalm-assert array{testStepFinished?: array} $arr
     */
    private static function ensureTestStepFinished(array $arr): void
    {
        if (array_key_exists('testStepFinished', $arr) && !is_array($arr['testStepFinished'])) {
            throw new SchemaViolationException('Property \'testStepFinished\' was not array');
        }
    }

    /**
     * @psalm-assert array{testStepStarted?: array} $arr
     */
    private static function ensureTestStepStarted(array $arr): void
    {
        if (array_key_exists('testStepStarted', $arr) && !is_array($arr['testStepStarted'])) {
            throw new SchemaViolationException('Property \'testStepStarted\' was not array');
        }
    }

    /**
     * @psalm-assert array{undefinedParameterType?: array} $arr
     */
    private static function ensureUndefinedParameterType(array $arr): void
    {
        if (array_key_exists('undefinedParameterType', $arr) && !is_array($arr['undefinedParameterType'])) {
            throw new SchemaViolationException('Property \'undefinedParameterType\' was not array');
        }
    }
}

GherkinDocument.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the GherkinDocument message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * The [AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree) of a Gherkin document.
 * Cucumber implementations should *not* depend on `GherkinDocument` or any of its
 * children for execution - use [Pickle](#io.cucumber.messages.Pickle) instead.
 * 
 * The only consumers of `GherkinDocument` should only be formatters that produce
 * "rich" output, resembling the original Gherkin document. */
final class GherkinDocument implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the GherkinDocument with all properties
     *
     * @param list<Comment> $comments
     */
    public function __construct(

        /**
         * The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
         * of the source, typically a file path relative to the root directory
         */
        public readonly ?string $uri = null,

        public readonly ?Feature $feature = null,

        /**
         * All the comments in the Gherkin document
         */
        public readonly array $comments = [],
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureUri($arr);
        self::ensureFeature($arr);
        self::ensureComments($arr);

        return new self(
            isset($arr['uri']) ? (string) $arr['uri'] : null,
            isset($arr['feature']) ? Feature::fromArray($arr['feature']) : null,
            array_values(array_map(fn (array $member) => Comment::fromArray($member), $arr['comments'])),
        );
    }

    /**
     * @psalm-assert array{uri?: string|int|bool} $arr
     */
    private static function ensureUri(array $arr): void
    {
        if (array_key_exists('uri', $arr) && is_array($arr['uri'])) {
            throw new SchemaViolationException('Property \'uri\' was array');
        }
    }

    /**
     * @psalm-assert array{feature?: array} $arr
     */
    private static function ensureFeature(array $arr): void
    {
        if (array_key_exists('feature', $arr) && !is_array($arr['feature'])) {
            throw new SchemaViolationException('Property \'feature\' was not array');
        }
    }

    /**
     * @psalm-assert array{comments: array} $arr
     */
    private static function ensureComments(array $arr): void
    {
        if (!array_key_exists('comments', $arr)) {
            throw new SchemaViolationException('Property \'comments\' is required but was not found');
        }
        if (array_key_exists('comments', $arr) && !is_array($arr['comments'])) {
            throw new SchemaViolationException('Property \'comments\' was not array');
        }
    }
}

Background.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Background message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Background implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Background with all properties
     *
     * @param list<Step> $steps
     */
    public function __construct(

        /**
         * The location of the `Background` keyword
         */
        public readonly Location $location = new Location(),

        public readonly string $keyword = '',

        public readonly string $name = '',

        public readonly string $description = '',

        public readonly array $steps = [],

        public readonly string $id = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureKeyword($arr);
        self::ensureName($arr);
        self::ensureDescription($arr);
        self::ensureSteps($arr);
        self::ensureId($arr);

        return new self(
            Location::fromArray($arr['location']),
            (string) $arr['keyword'],
            (string) $arr['name'],
            (string) $arr['description'],
            array_values(array_map(fn (array $member) => Step::fromArray($member), $arr['steps'])),
            (string) $arr['id'],
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{keyword: string|int|bool} $arr
     */
    private static function ensureKeyword(array $arr): void
    {
        if (!array_key_exists('keyword', $arr)) {
            throw new SchemaViolationException('Property \'keyword\' is required but was not found');
        }
        if (array_key_exists('keyword', $arr) && is_array($arr['keyword'])) {
            throw new SchemaViolationException('Property \'keyword\' was array');
        }
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{description: string|int|bool} $arr
     */
    private static function ensureDescription(array $arr): void
    {
        if (!array_key_exists('description', $arr)) {
            throw new SchemaViolationException('Property \'description\' is required but was not found');
        }
        if (array_key_exists('description', $arr) && is_array($arr['description'])) {
            throw new SchemaViolationException('Property \'description\' was array');
        }
    }

    /**
     * @psalm-assert array{steps: array} $arr
     */
    private static function ensureSteps(array $arr): void
    {
        if (!array_key_exists('steps', $arr)) {
            throw new SchemaViolationException('Property \'steps\' is required but was not found');
        }
        if (array_key_exists('steps', $arr) && !is_array($arr['steps'])) {
            throw new SchemaViolationException('Property \'steps\' was not array');
        }
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }
}

Comment.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Comment message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A comment in a Gherkin document */
final class Comment implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Comment with all properties
     *
     */
    public function __construct(

        /**
         * The location of the comment
         */
        public readonly Location $location = new Location(),

        /**
         * The text of the comment
         */
        public readonly string $text = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureText($arr);

        return new self(
            Location::fromArray($arr['location']),
            (string) $arr['text'],
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{text: string|int|bool} $arr
     */
    private static function ensureText(array $arr): void
    {
        if (!array_key_exists('text', $arr)) {
            throw new SchemaViolationException('Property \'text\' is required but was not found');
        }
        if (array_key_exists('text', $arr) && is_array($arr['text'])) {
            throw new SchemaViolationException('Property \'text\' was array');
        }
    }
}

DataTable.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the DataTable message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class DataTable implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the DataTable with all properties
     *
     * @param list<TableRow> $rows
     */
    public function __construct(

        public readonly Location $location = new Location(),

        public readonly array $rows = [],
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureRows($arr);

        return new self(
            Location::fromArray($arr['location']),
            array_values(array_map(fn (array $member) => TableRow::fromArray($member), $arr['rows'])),
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{rows: array} $arr
     */
    private static function ensureRows(array $arr): void
    {
        if (!array_key_exists('rows', $arr)) {
            throw new SchemaViolationException('Property \'rows\' is required but was not found');
        }
        if (array_key_exists('rows', $arr) && !is_array($arr['rows'])) {
            throw new SchemaViolationException('Property \'rows\' was not array');
        }
    }
}

DocString.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the DocString message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class DocString implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the DocString with all properties
     *
     */
    public function __construct(

        public readonly Location $location = new Location(),

        public readonly ?string $mediaType = null,

        public readonly string $content = '',

        public readonly string $delimiter = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureMediaType($arr);
        self::ensureContent($arr);
        self::ensureDelimiter($arr);

        return new self(
            Location::fromArray($arr['location']),
            isset($arr['mediaType']) ? (string) $arr['mediaType'] : null,
            (string) $arr['content'],
            (string) $arr['delimiter'],
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{mediaType?: string|int|bool} $arr
     */
    private static function ensureMediaType(array $arr): void
    {
        if (array_key_exists('mediaType', $arr) && is_array($arr['mediaType'])) {
            throw new SchemaViolationException('Property \'mediaType\' was array');
        }
    }

    /**
     * @psalm-assert array{content: string|int|bool} $arr
     */
    private static function ensureContent(array $arr): void
    {
        if (!array_key_exists('content', $arr)) {
            throw new SchemaViolationException('Property \'content\' is required but was not found');
        }
        if (array_key_exists('content', $arr) && is_array($arr['content'])) {
            throw new SchemaViolationException('Property \'content\' was array');
        }
    }

    /**
     * @psalm-assert array{delimiter: string|int|bool} $arr
     */
    private static function ensureDelimiter(array $arr): void
    {
        if (!array_key_exists('delimiter', $arr)) {
            throw new SchemaViolationException('Property \'delimiter\' is required but was not found');
        }
        if (array_key_exists('delimiter', $arr) && is_array($arr['delimiter'])) {
            throw new SchemaViolationException('Property \'delimiter\' was array');
        }
    }
}

Examples.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Examples message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Examples implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Examples with all properties
     *
     * @param list<Tag> $tags
     * @param list<TableRow> $tableBody
     */
    public function __construct(

        /**
         * The location of the `Examples` keyword
         */
        public readonly Location $location = new Location(),

        public readonly array $tags = [],

        public readonly string $keyword = '',

        public readonly string $name = '',

        public readonly string $description = '',

        public readonly ?TableRow $tableHeader = null,

        public readonly array $tableBody = [],

        public readonly string $id = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureTags($arr);
        self::ensureKeyword($arr);
        self::ensureName($arr);
        self::ensureDescription($arr);
        self::ensureTableHeader($arr);
        self::ensureTableBody($arr);
        self::ensureId($arr);

        return new self(
            Location::fromArray($arr['location']),
            array_values(array_map(fn (array $member) => Tag::fromArray($member), $arr['tags'])),
            (string) $arr['keyword'],
            (string) $arr['name'],
            (string) $arr['description'],
            isset($arr['tableHeader']) ? TableRow::fromArray($arr['tableHeader']) : null,
            array_values(array_map(fn (array $member) => TableRow::fromArray($member), $arr['tableBody'])),
            (string) $arr['id'],
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{tags: array} $arr
     */
    private static function ensureTags(array $arr): void
    {
        if (!array_key_exists('tags', $arr)) {
            throw new SchemaViolationException('Property \'tags\' is required but was not found');
        }
        if (array_key_exists('tags', $arr) && !is_array($arr['tags'])) {
            throw new SchemaViolationException('Property \'tags\' was not array');
        }
    }

    /**
     * @psalm-assert array{keyword: string|int|bool} $arr
     */
    private static function ensureKeyword(array $arr): void
    {
        if (!array_key_exists('keyword', $arr)) {
            throw new SchemaViolationException('Property \'keyword\' is required but was not found');
        }
        if (array_key_exists('keyword', $arr) && is_array($arr['keyword'])) {
            throw new SchemaViolationException('Property \'keyword\' was array');
        }
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{description: string|int|bool} $arr
     */
    private static function ensureDescription(array $arr): void
    {
        if (!array_key_exists('description', $arr)) {
            throw new SchemaViolationException('Property \'description\' is required but was not found');
        }
        if (array_key_exists('description', $arr) && is_array($arr['description'])) {
            throw new SchemaViolationException('Property \'description\' was array');
        }
    }

    /**
     * @psalm-assert array{tableHeader?: array} $arr
     */
    private static function ensureTableHeader(array $arr): void
    {
        if (array_key_exists('tableHeader', $arr) && !is_array($arr['tableHeader'])) {
            throw new SchemaViolationException('Property \'tableHeader\' was not array');
        }
    }

    /**
     * @psalm-assert array{tableBody: array} $arr
     */
    private static function ensureTableBody(array $arr): void
    {
        if (!array_key_exists('tableBody', $arr)) {
            throw new SchemaViolationException('Property \'tableBody\' is required but was not found');
        }
        if (array_key_exists('tableBody', $arr) && !is_array($arr['tableBody'])) {
            throw new SchemaViolationException('Property \'tableBody\' was not array');
        }
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }
}

Feature.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Feature message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Feature implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Feature with all properties
     *
     * @param list<Tag> $tags
     * @param list<FeatureChild> $children
     */
    public function __construct(

        /**
         * The location of the `Feature` keyword
         */
        public readonly Location $location = new Location(),

        /**
         * All the tags placed above the `Feature` keyword
         */
        public readonly array $tags = [],

        /**
         * The [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) language code of the Gherkin document
         */
        public readonly string $language = '',

        /**
         * The text of the `Feature` keyword (in the language specified by `language`)
         */
        public readonly string $keyword = '',

        /**
         * The name of the feature (the text following the `keyword`)
         */
        public readonly string $name = '',

        /**
         * The line(s) underneath the line with the `keyword` that are used as description
         */
        public readonly string $description = '',

        /**
         * Zero or more children
         */
        public readonly array $children = [],
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureTags($arr);
        self::ensureLanguage($arr);
        self::ensureKeyword($arr);
        self::ensureName($arr);
        self::ensureDescription($arr);
        self::ensureChildren($arr);

        return new self(
            Location::fromArray($arr['location']),
            array_values(array_map(fn (array $member) => Tag::fromArray($member), $arr['tags'])),
            (string) $arr['language'],
            (string) $arr['keyword'],
            (string) $arr['name'],
            (string) $arr['description'],
            array_values(array_map(fn (array $member) => FeatureChild::fromArray($member), $arr['children'])),
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{tags: array} $arr
     */
    private static function ensureTags(array $arr): void
    {
        if (!array_key_exists('tags', $arr)) {
            throw new SchemaViolationException('Property \'tags\' is required but was not found');
        }
        if (array_key_exists('tags', $arr) && !is_array($arr['tags'])) {
            throw new SchemaViolationException('Property \'tags\' was not array');
        }
    }

    /**
     * @psalm-assert array{language: string|int|bool} $arr
     */
    private static function ensureLanguage(array $arr): void
    {
        if (!array_key_exists('language', $arr)) {
            throw new SchemaViolationException('Property \'language\' is required but was not found');
        }
        if (array_key_exists('language', $arr) && is_array($arr['language'])) {
            throw new SchemaViolationException('Property \'language\' was array');
        }
    }

    /**
     * @psalm-assert array{keyword: string|int|bool} $arr
     */
    private static function ensureKeyword(array $arr): void
    {
        if (!array_key_exists('keyword', $arr)) {
            throw new SchemaViolationException('Property \'keyword\' is required but was not found');
        }
        if (array_key_exists('keyword', $arr) && is_array($arr['keyword'])) {
            throw new SchemaViolationException('Property \'keyword\' was array');
        }
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{description: string|int|bool} $arr
     */
    private static function ensureDescription(array $arr): void
    {
        if (!array_key_exists('description', $arr)) {
            throw new SchemaViolationException('Property \'description\' is required but was not found');
        }
        if (array_key_exists('description', $arr) && is_array($arr['description'])) {
            throw new SchemaViolationException('Property \'description\' was array');
        }
    }

    /**
     * @psalm-assert array{children: array} $arr
     */
    private static function ensureChildren(array $arr): void
    {
        if (!array_key_exists('children', $arr)) {
            throw new SchemaViolationException('Property \'children\' is required but was not found');
        }
        if (array_key_exists('children', $arr) && !is_array($arr['children'])) {
            throw new SchemaViolationException('Property \'children\' was not array');
        }
    }
}

FeatureChild.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the FeatureChild message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A child node of a `Feature` node */
final class FeatureChild implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the FeatureChild with all properties
     *
     */
    public function __construct(

        public readonly ?Rule $rule = null,

        public readonly ?Background $background = null,

        public readonly ?Scenario $scenario = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureRule($arr);
        self::ensureBackground($arr);
        self::ensureScenario($arr);

        return new self(
            isset($arr['rule']) ? Rule::fromArray($arr['rule']) : null,
            isset($arr['background']) ? Background::fromArray($arr['background']) : null,
            isset($arr['scenario']) ? Scenario::fromArray($arr['scenario']) : null,
        );
    }

    /**
     * @psalm-assert array{rule?: array} $arr
     */
    private static function ensureRule(array $arr): void
    {
        if (array_key_exists('rule', $arr) && !is_array($arr['rule'])) {
            throw new SchemaViolationException('Property \'rule\' was not array');
        }
    }

    /**
     * @psalm-assert array{background?: array} $arr
     */
    private static function ensureBackground(array $arr): void
    {
        if (array_key_exists('background', $arr) && !is_array($arr['background'])) {
            throw new SchemaViolationException('Property \'background\' was not array');
        }
    }

    /**
     * @psalm-assert array{scenario?: array} $arr
     */
    private static function ensureScenario(array $arr): void
    {
        if (array_key_exists('scenario', $arr) && !is_array($arr['scenario'])) {
            throw new SchemaViolationException('Property \'scenario\' was not array');
        }
    }
}

Rule.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Rule message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Rule implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Rule with all properties
     *
     * @param list<Tag> $tags
     * @param list<RuleChild> $children
     */
    public function __construct(

        /**
         * The location of the `Rule` keyword
         */
        public readonly Location $location = new Location(),

        /**
         * All the tags placed above the `Rule` keyword
         */
        public readonly array $tags = [],

        public readonly string $keyword = '',

        public readonly string $name = '',

        public readonly string $description = '',

        public readonly array $children = [],

        public readonly string $id = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureTags($arr);
        self::ensureKeyword($arr);
        self::ensureName($arr);
        self::ensureDescription($arr);
        self::ensureChildren($arr);
        self::ensureId($arr);

        return new self(
            Location::fromArray($arr['location']),
            array_values(array_map(fn (array $member) => Tag::fromArray($member), $arr['tags'])),
            (string) $arr['keyword'],
            (string) $arr['name'],
            (string) $arr['description'],
            array_values(array_map(fn (array $member) => RuleChild::fromArray($member), $arr['children'])),
            (string) $arr['id'],
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{tags: array} $arr
     */
    private static function ensureTags(array $arr): void
    {
        if (!array_key_exists('tags', $arr)) {
            throw new SchemaViolationException('Property \'tags\' is required but was not found');
        }
        if (array_key_exists('tags', $arr) && !is_array($arr['tags'])) {
            throw new SchemaViolationException('Property \'tags\' was not array');
        }
    }

    /**
     * @psalm-assert array{keyword: string|int|bool} $arr
     */
    private static function ensureKeyword(array $arr): void
    {
        if (!array_key_exists('keyword', $arr)) {
            throw new SchemaViolationException('Property \'keyword\' is required but was not found');
        }
        if (array_key_exists('keyword', $arr) && is_array($arr['keyword'])) {
            throw new SchemaViolationException('Property \'keyword\' was array');
        }
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{description: string|int|bool} $arr
     */
    private static function ensureDescription(array $arr): void
    {
        if (!array_key_exists('description', $arr)) {
            throw new SchemaViolationException('Property \'description\' is required but was not found');
        }
        if (array_key_exists('description', $arr) && is_array($arr['description'])) {
            throw new SchemaViolationException('Property \'description\' was array');
        }
    }

    /**
     * @psalm-assert array{children: array} $arr
     */
    private static function ensureChildren(array $arr): void
    {
        if (!array_key_exists('children', $arr)) {
            throw new SchemaViolationException('Property \'children\' is required but was not found');
        }
        if (array_key_exists('children', $arr) && !is_array($arr['children'])) {
            throw new SchemaViolationException('Property \'children\' was not array');
        }
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }
}

RuleChild.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the RuleChild message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A child node of a `Rule` node */
final class RuleChild implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the RuleChild with all properties
     *
     */
    public function __construct(

        public readonly ?Background $background = null,

        public readonly ?Scenario $scenario = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureBackground($arr);
        self::ensureScenario($arr);

        return new self(
            isset($arr['background']) ? Background::fromArray($arr['background']) : null,
            isset($arr['scenario']) ? Scenario::fromArray($arr['scenario']) : null,
        );
    }

    /**
     * @psalm-assert array{background?: array} $arr
     */
    private static function ensureBackground(array $arr): void
    {
        if (array_key_exists('background', $arr) && !is_array($arr['background'])) {
            throw new SchemaViolationException('Property \'background\' was not array');
        }
    }

    /**
     * @psalm-assert array{scenario?: array} $arr
     */
    private static function ensureScenario(array $arr): void
    {
        if (array_key_exists('scenario', $arr) && !is_array($arr['scenario'])) {
            throw new SchemaViolationException('Property \'scenario\' was not array');
        }
    }
}

Scenario.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Scenario message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Scenario implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Scenario with all properties
     *
     * @param list<Tag> $tags
     * @param list<Step> $steps
     * @param list<Examples> $examples
     */
    public function __construct(

        /**
         * The location of the `Scenario` keyword
         */
        public readonly Location $location = new Location(),

        public readonly array $tags = [],

        public readonly string $keyword = '',

        public readonly string $name = '',

        public readonly string $description = '',

        public readonly array $steps = [],

        public readonly array $examples = [],

        public readonly string $id = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureTags($arr);
        self::ensureKeyword($arr);
        self::ensureName($arr);
        self::ensureDescription($arr);
        self::ensureSteps($arr);
        self::ensureExamples($arr);
        self::ensureId($arr);

        return new self(
            Location::fromArray($arr['location']),
            array_values(array_map(fn (array $member) => Tag::fromArray($member), $arr['tags'])),
            (string) $arr['keyword'],
            (string) $arr['name'],
            (string) $arr['description'],
            array_values(array_map(fn (array $member) => Step::fromArray($member), $arr['steps'])),
            array_values(array_map(fn (array $member) => Examples::fromArray($member), $arr['examples'])),
            (string) $arr['id'],
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{tags: array} $arr
     */
    private static function ensureTags(array $arr): void
    {
        if (!array_key_exists('tags', $arr)) {
            throw new SchemaViolationException('Property \'tags\' is required but was not found');
        }
        if (array_key_exists('tags', $arr) && !is_array($arr['tags'])) {
            throw new SchemaViolationException('Property \'tags\' was not array');
        }
    }

    /**
     * @psalm-assert array{keyword: string|int|bool} $arr
     */
    private static function ensureKeyword(array $arr): void
    {
        if (!array_key_exists('keyword', $arr)) {
            throw new SchemaViolationException('Property \'keyword\' is required but was not found');
        }
        if (array_key_exists('keyword', $arr) && is_array($arr['keyword'])) {
            throw new SchemaViolationException('Property \'keyword\' was array');
        }
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{description: string|int|bool} $arr
     */
    private static function ensureDescription(array $arr): void
    {
        if (!array_key_exists('description', $arr)) {
            throw new SchemaViolationException('Property \'description\' is required but was not found');
        }
        if (array_key_exists('description', $arr) && is_array($arr['description'])) {
            throw new SchemaViolationException('Property \'description\' was array');
        }
    }

    /**
     * @psalm-assert array{steps: array} $arr
     */
    private static function ensureSteps(array $arr): void
    {
        if (!array_key_exists('steps', $arr)) {
            throw new SchemaViolationException('Property \'steps\' is required but was not found');
        }
        if (array_key_exists('steps', $arr) && !is_array($arr['steps'])) {
            throw new SchemaViolationException('Property \'steps\' was not array');
        }
    }

    /**
     * @psalm-assert array{examples: array} $arr
     */
    private static function ensureExamples(array $arr): void
    {
        if (!array_key_exists('examples', $arr)) {
            throw new SchemaViolationException('Property \'examples\' is required but was not found');
        }
        if (array_key_exists('examples', $arr) && !is_array($arr['examples'])) {
            throw new SchemaViolationException('Property \'examples\' was not array');
        }
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }
}

Step.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Step message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A step */
final class Step implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Step with all properties
     *
     */
    public function __construct(

        /**
         * The location of the steps' `keyword`
         */
        public readonly Location $location = new Location(),

        /**
         * The actual keyword as it appeared in the source.
         */
        public readonly string $keyword = '',

        /**
         * The test phase signalled by the keyword: Context definition (Given), Action performance (When), Outcome assertion (Then). Other keywords signal Continuation (And and But) from a prior keyword. Please note that all translations which a dialect maps to multiple keywords (`*` is in this category for all dialects), map to 'Unknown'.
         */
        public readonly ?Step\KeywordType $keywordType = null,

        public readonly string $text = '',

        public readonly ?DocString $docString = null,

        public readonly ?DataTable $dataTable = null,

        /**
         * Unique ID to be able to reference the Step from PickleStep
         */
        public readonly string $id = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureKeyword($arr);
        self::ensureKeywordType($arr);
        self::ensureText($arr);
        self::ensureDocString($arr);
        self::ensureDataTable($arr);
        self::ensureId($arr);

        return new self(
            Location::fromArray($arr['location']),
            (string) $arr['keyword'],
            isset($arr['keywordType']) ? Step\KeywordType::from((string) $arr['keywordType']) : null,
            (string) $arr['text'],
            isset($arr['docString']) ? DocString::fromArray($arr['docString']) : null,
            isset($arr['dataTable']) ? DataTable::fromArray($arr['dataTable']) : null,
            (string) $arr['id'],
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{keyword: string|int|bool} $arr
     */
    private static function ensureKeyword(array $arr): void
    {
        if (!array_key_exists('keyword', $arr)) {
            throw new SchemaViolationException('Property \'keyword\' is required but was not found');
        }
        if (array_key_exists('keyword', $arr) && is_array($arr['keyword'])) {
            throw new SchemaViolationException('Property \'keyword\' was array');
        }
    }

    /**
     * @psalm-assert array{keywordType?: string|int|bool} $arr
     */
    private static function ensureKeywordType(array $arr): void
    {
        if (array_key_exists('keywordType', $arr) && is_array($arr['keywordType'])) {
            throw new SchemaViolationException('Property \'keywordType\' was array');
        }
    }

    /**
     * @psalm-assert array{text: string|int|bool} $arr
     */
    private static function ensureText(array $arr): void
    {
        if (!array_key_exists('text', $arr)) {
            throw new SchemaViolationException('Property \'text\' is required but was not found');
        }
        if (array_key_exists('text', $arr) && is_array($arr['text'])) {
            throw new SchemaViolationException('Property \'text\' was array');
        }
    }

    /**
     * @psalm-assert array{docString?: array} $arr
     */
    private static function ensureDocString(array $arr): void
    {
        if (array_key_exists('docString', $arr) && !is_array($arr['docString'])) {
            throw new SchemaViolationException('Property \'docString\' was not array');
        }
    }

    /**
     * @psalm-assert array{dataTable?: array} $arr
     */
    private static function ensureDataTable(array $arr): void
    {
        if (array_key_exists('dataTable', $arr) && !is_array($arr['dataTable'])) {
            throw new SchemaViolationException('Property \'dataTable\' was not array');
        }
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }
}

TableCell.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the TableCell message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A cell in a `TableRow` */
final class TableCell implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the TableCell with all properties
     *
     */
    public function __construct(

        /**
         * The location of the cell
         */
        public readonly Location $location = new Location(),

        /**
         * The value of the cell
         */
        public readonly string $value = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureValue($arr);

        return new self(
            Location::fromArray($arr['location']),
            (string) $arr['value'],
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{value: string|int|bool} $arr
     */
    private static function ensureValue(array $arr): void
    {
        if (!array_key_exists('value', $arr)) {
            throw new SchemaViolationException('Property \'value\' is required but was not found');
        }
        if (array_key_exists('value', $arr) && is_array($arr['value'])) {
            throw new SchemaViolationException('Property \'value\' was array');
        }
    }
}

TableRow.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the TableRow message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A row in a table */
final class TableRow implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the TableRow with all properties
     *
     * @param list<TableCell> $cells
     */
    public function __construct(

        /**
         * The location of the first cell in the row
         */
        public readonly Location $location = new Location(),

        /**
         * Cells in the row
         */
        public readonly array $cells = [],

        public readonly string $id = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureCells($arr);
        self::ensureId($arr);

        return new self(
            Location::fromArray($arr['location']),
            array_values(array_map(fn (array $member) => TableCell::fromArray($member), $arr['cells'])),
            (string) $arr['id'],
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{cells: array} $arr
     */
    private static function ensureCells(array $arr): void
    {
        if (!array_key_exists('cells', $arr)) {
            throw new SchemaViolationException('Property \'cells\' is required but was not found');
        }
        if (array_key_exists('cells', $arr) && !is_array($arr['cells'])) {
            throw new SchemaViolationException('Property \'cells\' was not array');
        }
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }
}

Tag.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Tag message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A tag */
final class Tag implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Tag with all properties
     *
     */
    public function __construct(

        /**
         * Location of the tag
         */
        public readonly Location $location = new Location(),

        /**
         * The name of the tag (including the leading `@`)
         */
        public readonly string $name = '',

        /**
         * Unique ID to be able to reference the Tag from PickleTag
         */
        public readonly string $id = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLocation($arr);
        self::ensureName($arr);
        self::ensureId($arr);

        return new self(
            Location::fromArray($arr['location']),
            (string) $arr['name'],
            (string) $arr['id'],
        );
    }

    /**
     * @psalm-assert array{location: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (!array_key_exists('location', $arr)) {
            throw new SchemaViolationException('Property \'location\' is required but was not found');
        }
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }
}

Hook.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Hook message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Hook implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Hook with all properties
     *
     */
    public function __construct(

        public readonly string $id = '',

        public readonly ?string $name = null,

        public readonly SourceReference $sourceReference = new SourceReference(),

        public readonly ?string $tagExpression = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureId($arr);
        self::ensureName($arr);
        self::ensureSourceReference($arr);
        self::ensureTagExpression($arr);

        return new self(
            (string) $arr['id'],
            isset($arr['name']) ? (string) $arr['name'] : null,
            SourceReference::fromArray($arr['sourceReference']),
            isset($arr['tagExpression']) ? (string) $arr['tagExpression'] : null,
        );
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }

    /**
     * @psalm-assert array{name?: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{sourceReference: array} $arr
     */
    private static function ensureSourceReference(array $arr): void
    {
        if (!array_key_exists('sourceReference', $arr)) {
            throw new SchemaViolationException('Property \'sourceReference\' is required but was not found');
        }
        if (array_key_exists('sourceReference', $arr) && !is_array($arr['sourceReference'])) {
            throw new SchemaViolationException('Property \'sourceReference\' was not array');
        }
    }

    /**
     * @psalm-assert array{tagExpression?: string|int|bool} $arr
     */
    private static function ensureTagExpression(array $arr): void
    {
        if (array_key_exists('tagExpression', $arr) && is_array($arr['tagExpression'])) {
            throw new SchemaViolationException('Property \'tagExpression\' was array');
        }
    }
}

Location.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Location message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * Points to a line and a column in a text file */
final class Location implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Location with all properties
     *
     */
    public function __construct(

        public readonly int $line = 0,

        public readonly ?int $column = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureLine($arr);
        self::ensureColumn($arr);

        return new self(
            (int) $arr['line'],
            isset($arr['column']) ? (int) $arr['column'] : null,
        );
    }

    /**
     * @psalm-assert array{line: string|int|bool} $arr
     */
    private static function ensureLine(array $arr): void
    {
        if (!array_key_exists('line', $arr)) {
            throw new SchemaViolationException('Property \'line\' is required but was not found');
        }
        if (array_key_exists('line', $arr) && is_array($arr['line'])) {
            throw new SchemaViolationException('Property \'line\' was array');
        }
    }

    /**
     * @psalm-assert array{column?: string|int|bool} $arr
     */
    private static function ensureColumn(array $arr): void
    {
        if (array_key_exists('column', $arr) && is_array($arr['column'])) {
            throw new SchemaViolationException('Property \'column\' was array');
        }
    }
}

Meta.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Meta message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * This message contains meta information about the environment. Consumers can use
 * this for various purposes. */
final class Meta implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Meta with all properties
     *
     */
    public function __construct(

        /**
         * The [SEMVER](https://semver.org/) version number of the protocol
         */
        public readonly string $protocolVersion = '',

        /**
         * SpecFlow, Cucumber-JVM, Cucumber.js, Cucumber-Ruby, Behat etc.
         */
        public readonly Product $implementation = new Product(),

        /**
         * Java, Ruby, Node.js etc
         */
        public readonly Product $runtime = new Product(),

        /**
         * Windows, Linux, MacOS etc
         */
        public readonly Product $os = new Product(),

        /**
         * 386, arm, amd64 etc
         */
        public readonly Product $cpu = new Product(),

        public readonly ?Ci $ci = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureProtocolVersion($arr);
        self::ensureImplementation($arr);
        self::ensureRuntime($arr);
        self::ensureOs($arr);
        self::ensureCpu($arr);
        self::ensureCi($arr);

        return new self(
            (string) $arr['protocolVersion'],
            Product::fromArray($arr['implementation']),
            Product::fromArray($arr['runtime']),
            Product::fromArray($arr['os']),
            Product::fromArray($arr['cpu']),
            isset($arr['ci']) ? Ci::fromArray($arr['ci']) : null,
        );
    }

    /**
     * @psalm-assert array{protocolVersion: string|int|bool} $arr
     */
    private static function ensureProtocolVersion(array $arr): void
    {
        if (!array_key_exists('protocolVersion', $arr)) {
            throw new SchemaViolationException('Property \'protocolVersion\' is required but was not found');
        }
        if (array_key_exists('protocolVersion', $arr) && is_array($arr['protocolVersion'])) {
            throw new SchemaViolationException('Property \'protocolVersion\' was array');
        }
    }

    /**
     * @psalm-assert array{implementation: array} $arr
     */
    private static function ensureImplementation(array $arr): void
    {
        if (!array_key_exists('implementation', $arr)) {
            throw new SchemaViolationException('Property \'implementation\' is required but was not found');
        }
        if (array_key_exists('implementation', $arr) && !is_array($arr['implementation'])) {
            throw new SchemaViolationException('Property \'implementation\' was not array');
        }
    }

    /**
     * @psalm-assert array{runtime: array} $arr
     */
    private static function ensureRuntime(array $arr): void
    {
        if (!array_key_exists('runtime', $arr)) {
            throw new SchemaViolationException('Property \'runtime\' is required but was not found');
        }
        if (array_key_exists('runtime', $arr) && !is_array($arr['runtime'])) {
            throw new SchemaViolationException('Property \'runtime\' was not array');
        }
    }

    /**
     * @psalm-assert array{os: array} $arr
     */
    private static function ensureOs(array $arr): void
    {
        if (!array_key_exists('os', $arr)) {
            throw new SchemaViolationException('Property \'os\' is required but was not found');
        }
        if (array_key_exists('os', $arr) && !is_array($arr['os'])) {
            throw new SchemaViolationException('Property \'os\' was not array');
        }
    }

    /**
     * @psalm-assert array{cpu: array} $arr
     */
    private static function ensureCpu(array $arr): void
    {
        if (!array_key_exists('cpu', $arr)) {
            throw new SchemaViolationException('Property \'cpu\' is required but was not found');
        }
        if (array_key_exists('cpu', $arr) && !is_array($arr['cpu'])) {
            throw new SchemaViolationException('Property \'cpu\' was not array');
        }
    }

    /**
     * @psalm-assert array{ci?: array} $arr
     */
    private static function ensureCi(array $arr): void
    {
        if (array_key_exists('ci', $arr) && !is_array($arr['ci'])) {
            throw new SchemaViolationException('Property \'ci\' was not array');
        }
    }
}

Ci.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Ci message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * CI environment */
final class Ci implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Ci with all properties
     *
     */
    public function __construct(

        /**
         * Name of the CI product, e.g. "Jenkins", "CircleCI" etc.
         */
        public readonly string $name = '',

        /**
         * Link to the build
         */
        public readonly ?string $url = null,

        /**
         * The build number. Some CI servers use non-numeric build numbers, which is why this is a string
         */
        public readonly ?string $buildNumber = null,

        public readonly ?Git $git = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureName($arr);
        self::ensureUrl($arr);
        self::ensureBuildNumber($arr);
        self::ensureGit($arr);

        return new self(
            (string) $arr['name'],
            isset($arr['url']) ? (string) $arr['url'] : null,
            isset($arr['buildNumber']) ? (string) $arr['buildNumber'] : null,
            isset($arr['git']) ? Git::fromArray($arr['git']) : null,
        );
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{url?: string|int|bool} $arr
     */
    private static function ensureUrl(array $arr): void
    {
        if (array_key_exists('url', $arr) && is_array($arr['url'])) {
            throw new SchemaViolationException('Property \'url\' was array');
        }
    }

    /**
     * @psalm-assert array{buildNumber?: string|int|bool} $arr
     */
    private static function ensureBuildNumber(array $arr): void
    {
        if (array_key_exists('buildNumber', $arr) && is_array($arr['buildNumber'])) {
            throw new SchemaViolationException('Property \'buildNumber\' was array');
        }
    }

    /**
     * @psalm-assert array{git?: array} $arr
     */
    private static function ensureGit(array $arr): void
    {
        if (array_key_exists('git', $arr) && !is_array($arr['git'])) {
            throw new SchemaViolationException('Property \'git\' was not array');
        }
    }
}

Git.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Git message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * Information about Git, provided by the Build/CI server as environment
 * variables. */
final class Git implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Git with all properties
     *
     */
    public function __construct(

        public readonly string $remote = '',

        public readonly string $revision = '',

        public readonly ?string $branch = null,

        public readonly ?string $tag = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureRemote($arr);
        self::ensureRevision($arr);
        self::ensureBranch($arr);
        self::ensureTag($arr);

        return new self(
            (string) $arr['remote'],
            (string) $arr['revision'],
            isset($arr['branch']) ? (string) $arr['branch'] : null,
            isset($arr['tag']) ? (string) $arr['tag'] : null,
        );
    }

    /**
     * @psalm-assert array{remote: string|int|bool} $arr
     */
    private static function ensureRemote(array $arr): void
    {
        if (!array_key_exists('remote', $arr)) {
            throw new SchemaViolationException('Property \'remote\' is required but was not found');
        }
        if (array_key_exists('remote', $arr) && is_array($arr['remote'])) {
            throw new SchemaViolationException('Property \'remote\' was array');
        }
    }

    /**
     * @psalm-assert array{revision: string|int|bool} $arr
     */
    private static function ensureRevision(array $arr): void
    {
        if (!array_key_exists('revision', $arr)) {
            throw new SchemaViolationException('Property \'revision\' is required but was not found');
        }
        if (array_key_exists('revision', $arr) && is_array($arr['revision'])) {
            throw new SchemaViolationException('Property \'revision\' was array');
        }
    }

    /**
     * @psalm-assert array{branch?: string|int|bool} $arr
     */
    private static function ensureBranch(array $arr): void
    {
        if (array_key_exists('branch', $arr) && is_array($arr['branch'])) {
            throw new SchemaViolationException('Property \'branch\' was array');
        }
    }

    /**
     * @psalm-assert array{tag?: string|int|bool} $arr
     */
    private static function ensureTag(array $arr): void
    {
        if (array_key_exists('tag', $arr) && is_array($arr['tag'])) {
            throw new SchemaViolationException('Property \'tag\' was array');
        }
    }
}

Product.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Product message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * Used to describe various properties of Meta */
final class Product implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Product with all properties
     *
     */
    public function __construct(

        /**
         * The product name
         */
        public readonly string $name = '',

        /**
         * The product version
         */
        public readonly ?string $version = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureName($arr);
        self::ensureVersion($arr);

        return new self(
            (string) $arr['name'],
            isset($arr['version']) ? (string) $arr['version'] : null,
        );
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{version?: string|int|bool} $arr
     */
    private static function ensureVersion(array $arr): void
    {
        if (array_key_exists('version', $arr) && is_array($arr['version'])) {
            throw new SchemaViolationException('Property \'version\' was array');
        }
    }
}

ParameterType.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the ParameterType message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class ParameterType implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the ParameterType with all properties
     *
     * @param list<string> $regularExpressions
     */
    public function __construct(

        /**
         * The name is unique, so we don't need an id.
         */
        public readonly string $name = '',

        public readonly array $regularExpressions = [],

        public readonly bool $preferForRegularExpressionMatch = false,

        public readonly bool $useForSnippets = false,

        public readonly string $id = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureName($arr);
        self::ensureRegularExpressions($arr);
        self::ensurePreferForRegularExpressionMatch($arr);
        self::ensureUseForSnippets($arr);
        self::ensureId($arr);

        return new self(
            (string) $arr['name'],
            array_values(array_map(fn (mixed $member) => (string) $member, $arr['regularExpressions'])),
            (bool) $arr['preferForRegularExpressionMatch'],
            (bool) $arr['useForSnippets'],
            (string) $arr['id'],
        );
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{regularExpressions: array} $arr
     */
    private static function ensureRegularExpressions(array $arr): void
    {
        if (!array_key_exists('regularExpressions', $arr)) {
            throw new SchemaViolationException('Property \'regularExpressions\' is required but was not found');
        }
        if (array_key_exists('regularExpressions', $arr) && !is_array($arr['regularExpressions'])) {
            throw new SchemaViolationException('Property \'regularExpressions\' was not array');
        }
    }

    /**
     * @psalm-assert array{preferForRegularExpressionMatch: string|int|bool} $arr
     */
    private static function ensurePreferForRegularExpressionMatch(array $arr): void
    {
        if (!array_key_exists('preferForRegularExpressionMatch', $arr)) {
            throw new SchemaViolationException('Property \'preferForRegularExpressionMatch\' is required but was not found');
        }
        if (array_key_exists('preferForRegularExpressionMatch', $arr) && is_array($arr['preferForRegularExpressionMatch'])) {
            throw new SchemaViolationException('Property \'preferForRegularExpressionMatch\' was array');
        }
    }

    /**
     * @psalm-assert array{useForSnippets: string|int|bool} $arr
     */
    private static function ensureUseForSnippets(array $arr): void
    {
        if (!array_key_exists('useForSnippets', $arr)) {
            throw new SchemaViolationException('Property \'useForSnippets\' is required but was not found');
        }
        if (array_key_exists('useForSnippets', $arr) && is_array($arr['useForSnippets'])) {
            throw new SchemaViolationException('Property \'useForSnippets\' was array');
        }
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }
}

ParseError.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the ParseError message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class ParseError implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the ParseError with all properties
     *
     */
    public function __construct(

        public readonly SourceReference $source = new SourceReference(),

        public readonly string $message = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureSource($arr);
        self::ensureMessage($arr);

        return new self(
            SourceReference::fromArray($arr['source']),
            (string) $arr['message'],
        );
    }

    /**
     * @psalm-assert array{source: array} $arr
     */
    private static function ensureSource(array $arr): void
    {
        if (!array_key_exists('source', $arr)) {
            throw new SchemaViolationException('Property \'source\' is required but was not found');
        }
        if (array_key_exists('source', $arr) && !is_array($arr['source'])) {
            throw new SchemaViolationException('Property \'source\' was not array');
        }
    }

    /**
     * @psalm-assert array{message: string|int|bool} $arr
     */
    private static function ensureMessage(array $arr): void
    {
        if (!array_key_exists('message', $arr)) {
            throw new SchemaViolationException('Property \'message\' is required but was not found');
        }
        if (array_key_exists('message', $arr) && is_array($arr['message'])) {
            throw new SchemaViolationException('Property \'message\' was array');
        }
    }
}

Pickle.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Pickle message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * //// Pickles
 * 
 * A `Pickle` represents a template for a `TestCase`. It is typically derived
 * from another format, such as [GherkinDocument](#io.cucumber.messages.GherkinDocument).
 * In the future a `Pickle` may be derived from other formats such as Markdown or
 * Excel files.
 * 
 * By making `Pickle` the main data structure Cucumber uses for execution, the
 * implementation of Cucumber itself becomes simpler, as it doesn't have to deal
 * with the complex structure of a [GherkinDocument](#io.cucumber.messages.GherkinDocument).
 * 
 * Each `PickleStep` of a `Pickle` is matched with a `StepDefinition` to create a `TestCase` */
final class Pickle implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Pickle with all properties
     *
     * @param list<PickleStep> $steps
     * @param list<PickleTag> $tags
     * @param list<string> $astNodeIds
     */
    public function __construct(

        /**
         * A unique id for the pickle
         */
        public readonly string $id = '',

        /**
         * The uri of the source file
         */
        public readonly string $uri = '',

        /**
         * The name of the pickle
         */
        public readonly string $name = '',

        /**
         * The language of the pickle
         */
        public readonly string $language = '',

        /**
         * One or more steps
         */
        public readonly array $steps = [],

        /**
         * One or more tags. If this pickle is constructed from a Gherkin document,
         * It includes inherited tags from the `Feature` as well.
         */
        public readonly array $tags = [],

        /**
         * Points to the AST node locations of the pickle. The last one represents the unique
         * id of the pickle. A pickle constructed from `Examples` will have the first
         * id originating from the `Scenario` AST node, and the second from the `TableRow` AST node.
         */
        public readonly array $astNodeIds = [],
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureId($arr);
        self::ensureUri($arr);
        self::ensureName($arr);
        self::ensureLanguage($arr);
        self::ensureSteps($arr);
        self::ensureTags($arr);
        self::ensureAstNodeIds($arr);

        return new self(
            (string) $arr['id'],
            (string) $arr['uri'],
            (string) $arr['name'],
            (string) $arr['language'],
            array_values(array_map(fn (array $member) => PickleStep::fromArray($member), $arr['steps'])),
            array_values(array_map(fn (array $member) => PickleTag::fromArray($member), $arr['tags'])),
            array_values(array_map(fn (mixed $member) => (string) $member, $arr['astNodeIds'])),
        );
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }

    /**
     * @psalm-assert array{uri: string|int|bool} $arr
     */
    private static function ensureUri(array $arr): void
    {
        if (!array_key_exists('uri', $arr)) {
            throw new SchemaViolationException('Property \'uri\' is required but was not found');
        }
        if (array_key_exists('uri', $arr) && is_array($arr['uri'])) {
            throw new SchemaViolationException('Property \'uri\' was array');
        }
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{language: string|int|bool} $arr
     */
    private static function ensureLanguage(array $arr): void
    {
        if (!array_key_exists('language', $arr)) {
            throw new SchemaViolationException('Property \'language\' is required but was not found');
        }
        if (array_key_exists('language', $arr) && is_array($arr['language'])) {
            throw new SchemaViolationException('Property \'language\' was array');
        }
    }

    /**
     * @psalm-assert array{steps: array} $arr
     */
    private static function ensureSteps(array $arr): void
    {
        if (!array_key_exists('steps', $arr)) {
            throw new SchemaViolationException('Property \'steps\' is required but was not found');
        }
        if (array_key_exists('steps', $arr) && !is_array($arr['steps'])) {
            throw new SchemaViolationException('Property \'steps\' was not array');
        }
    }

    /**
     * @psalm-assert array{tags: array} $arr
     */
    private static function ensureTags(array $arr): void
    {
        if (!array_key_exists('tags', $arr)) {
            throw new SchemaViolationException('Property \'tags\' is required but was not found');
        }
        if (array_key_exists('tags', $arr) && !is_array($arr['tags'])) {
            throw new SchemaViolationException('Property \'tags\' was not array');
        }
    }

    /**
     * @psalm-assert array{astNodeIds: array} $arr
     */
    private static function ensureAstNodeIds(array $arr): void
    {
        if (!array_key_exists('astNodeIds', $arr)) {
            throw new SchemaViolationException('Property \'astNodeIds\' is required but was not found');
        }
        if (array_key_exists('astNodeIds', $arr) && !is_array($arr['astNodeIds'])) {
            throw new SchemaViolationException('Property \'astNodeIds\' was not array');
        }
    }
}

PickleDocString.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the PickleDocString message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class PickleDocString implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the PickleDocString with all properties
     *
     */
    public function __construct(

        public readonly ?string $mediaType = null,

        public readonly string $content = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureMediaType($arr);
        self::ensureContent($arr);

        return new self(
            isset($arr['mediaType']) ? (string) $arr['mediaType'] : null,
            (string) $arr['content'],
        );
    }

    /**
     * @psalm-assert array{mediaType?: string|int|bool} $arr
     */
    private static function ensureMediaType(array $arr): void
    {
        if (array_key_exists('mediaType', $arr) && is_array($arr['mediaType'])) {
            throw new SchemaViolationException('Property \'mediaType\' was array');
        }
    }

    /**
     * @psalm-assert array{content: string|int|bool} $arr
     */
    private static function ensureContent(array $arr): void
    {
        if (!array_key_exists('content', $arr)) {
            throw new SchemaViolationException('Property \'content\' is required but was not found');
        }
        if (array_key_exists('content', $arr) && is_array($arr['content'])) {
            throw new SchemaViolationException('Property \'content\' was array');
        }
    }
}

PickleStep.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the PickleStep message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * An executable step */
final class PickleStep implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the PickleStep with all properties
     *
     * @param list<string> $astNodeIds
     */
    public function __construct(

        public readonly ?PickleStepArgument $argument = null,

        /**
         * References the IDs of the source of the step. For Gherkin, this can be
         * the ID of a Step, and possibly also the ID of a TableRow
         */
        public readonly array $astNodeIds = [],

        /**
         * A unique ID for the PickleStep
         */
        public readonly string $id = '',

        /**
         * The context in which the step was specified: context (Given), action (When) or outcome (Then).
         * 
         * Note that the keywords `But` and `And` inherit their meaning from prior steps and the `*` 'keyword' doesn't have specific meaning (hence Unknown)
         */
        public readonly ?PickleStep\Type $type = null,

        public readonly string $text = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureArgument($arr);
        self::ensureAstNodeIds($arr);
        self::ensureId($arr);
        self::ensureType($arr);
        self::ensureText($arr);

        return new self(
            isset($arr['argument']) ? PickleStepArgument::fromArray($arr['argument']) : null,
            array_values(array_map(fn (mixed $member) => (string) $member, $arr['astNodeIds'])),
            (string) $arr['id'],
            isset($arr['type']) ? PickleStep\Type::from((string) $arr['type']) : null,
            (string) $arr['text'],
        );
    }

    /**
     * @psalm-assert array{argument?: array} $arr
     */
    private static function ensureArgument(array $arr): void
    {
        if (array_key_exists('argument', $arr) && !is_array($arr['argument'])) {
            throw new SchemaViolationException('Property \'argument\' was not array');
        }
    }

    /**
     * @psalm-assert array{astNodeIds: array} $arr
     */
    private static function ensureAstNodeIds(array $arr): void
    {
        if (!array_key_exists('astNodeIds', $arr)) {
            throw new SchemaViolationException('Property \'astNodeIds\' is required but was not found');
        }
        if (array_key_exists('astNodeIds', $arr) && !is_array($arr['astNodeIds'])) {
            throw new SchemaViolationException('Property \'astNodeIds\' was not array');
        }
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }

    /**
     * @psalm-assert array{type?: string|int|bool} $arr
     */
    private static function ensureType(array $arr): void
    {
        if (array_key_exists('type', $arr) && is_array($arr['type'])) {
            throw new SchemaViolationException('Property \'type\' was array');
        }
    }

    /**
     * @psalm-assert array{text: string|int|bool} $arr
     */
    private static function ensureText(array $arr): void
    {
        if (!array_key_exists('text', $arr)) {
            throw new SchemaViolationException('Property \'text\' is required but was not found');
        }
        if (array_key_exists('text', $arr) && is_array($arr['text'])) {
            throw new SchemaViolationException('Property \'text\' was array');
        }
    }
}

PickleStepArgument.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the PickleStepArgument message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * An optional argument */
final class PickleStepArgument implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the PickleStepArgument with all properties
     *
     */
    public function __construct(

        public readonly ?PickleDocString $docString = null,

        public readonly ?PickleTable $dataTable = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureDocString($arr);
        self::ensureDataTable($arr);

        return new self(
            isset($arr['docString']) ? PickleDocString::fromArray($arr['docString']) : null,
            isset($arr['dataTable']) ? PickleTable::fromArray($arr['dataTable']) : null,
        );
    }

    /**
     * @psalm-assert array{docString?: array} $arr
     */
    private static function ensureDocString(array $arr): void
    {
        if (array_key_exists('docString', $arr) && !is_array($arr['docString'])) {
            throw new SchemaViolationException('Property \'docString\' was not array');
        }
    }

    /**
     * @psalm-assert array{dataTable?: array} $arr
     */
    private static function ensureDataTable(array $arr): void
    {
        if (array_key_exists('dataTable', $arr) && !is_array($arr['dataTable'])) {
            throw new SchemaViolationException('Property \'dataTable\' was not array');
        }
    }
}

PickleTable.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the PickleTable message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class PickleTable implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the PickleTable with all properties
     *
     * @param list<PickleTableRow> $rows
     */
    public function __construct(

        public readonly array $rows = [],
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureRows($arr);

        return new self(
            array_values(array_map(fn (array $member) => PickleTableRow::fromArray($member), $arr['rows'])),
        );
    }

    /**
     * @psalm-assert array{rows: array} $arr
     */
    private static function ensureRows(array $arr): void
    {
        if (!array_key_exists('rows', $arr)) {
            throw new SchemaViolationException('Property \'rows\' is required but was not found');
        }
        if (array_key_exists('rows', $arr) && !is_array($arr['rows'])) {
            throw new SchemaViolationException('Property \'rows\' was not array');
        }
    }
}

PickleTableCell.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the PickleTableCell message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class PickleTableCell implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the PickleTableCell with all properties
     *
     */
    public function __construct(

        public readonly string $value = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureValue($arr);

        return new self(
            (string) $arr['value'],
        );
    }

    /**
     * @psalm-assert array{value: string|int|bool} $arr
     */
    private static function ensureValue(array $arr): void
    {
        if (!array_key_exists('value', $arr)) {
            throw new SchemaViolationException('Property \'value\' is required but was not found');
        }
        if (array_key_exists('value', $arr) && is_array($arr['value'])) {
            throw new SchemaViolationException('Property \'value\' was array');
        }
    }
}

PickleTableRow.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the PickleTableRow message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class PickleTableRow implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the PickleTableRow with all properties
     *
     * @param list<PickleTableCell> $cells
     */
    public function __construct(

        public readonly array $cells = [],
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureCells($arr);

        return new self(
            array_values(array_map(fn (array $member) => PickleTableCell::fromArray($member), $arr['cells'])),
        );
    }

    /**
     * @psalm-assert array{cells: array} $arr
     */
    private static function ensureCells(array $arr): void
    {
        if (!array_key_exists('cells', $arr)) {
            throw new SchemaViolationException('Property \'cells\' is required but was not found');
        }
        if (array_key_exists('cells', $arr) && !is_array($arr['cells'])) {
            throw new SchemaViolationException('Property \'cells\' was not array');
        }
    }
}

PickleTag.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the PickleTag message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A tag */
final class PickleTag implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the PickleTag with all properties
     *
     */
    public function __construct(

        public readonly string $name = '',

        /**
         * Points to the AST node this was created from
         */
        public readonly string $astNodeId = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureName($arr);
        self::ensureAstNodeId($arr);

        return new self(
            (string) $arr['name'],
            (string) $arr['astNodeId'],
        );
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }

    /**
     * @psalm-assert array{astNodeId: string|int|bool} $arr
     */
    private static function ensureAstNodeId(array $arr): void
    {
        if (!array_key_exists('astNodeId', $arr)) {
            throw new SchemaViolationException('Property \'astNodeId\' is required but was not found');
        }
        if (array_key_exists('astNodeId', $arr) && is_array($arr['astNodeId'])) {
            throw new SchemaViolationException('Property \'astNodeId\' was array');
        }
    }
}

Source.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Source message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * //// Source
 * 
 * A source file, typically a Gherkin document or Java/Ruby/JavaScript source code */
final class Source implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Source with all properties
     *
     */
    public function __construct(

        /**
         * The [URI](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)
         * of the source, typically a file path relative to the root directory
         */
        public readonly string $uri = '',

        /**
         * The contents of the file
         */
        public readonly string $data = '',

        /**
         * The media type of the file. Can be used to specify custom types, such as
         * text/x.cucumber.gherkin+plain
         */
        public readonly Source\MediaType $mediaType = Source\MediaType::TEXT_X_CUCUMBER_GHERKIN_PLAIN,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureUri($arr);
        self::ensureData($arr);
        self::ensureMediaType($arr);

        return new self(
            (string) $arr['uri'],
            (string) $arr['data'],
            Source\MediaType::from((string) $arr['mediaType']),
        );
    }

    /**
     * @psalm-assert array{uri: string|int|bool} $arr
     */
    private static function ensureUri(array $arr): void
    {
        if (!array_key_exists('uri', $arr)) {
            throw new SchemaViolationException('Property \'uri\' is required but was not found');
        }
        if (array_key_exists('uri', $arr) && is_array($arr['uri'])) {
            throw new SchemaViolationException('Property \'uri\' was array');
        }
    }

    /**
     * @psalm-assert array{data: string|int|bool} $arr
     */
    private static function ensureData(array $arr): void
    {
        if (!array_key_exists('data', $arr)) {
            throw new SchemaViolationException('Property \'data\' is required but was not found');
        }
        if (array_key_exists('data', $arr) && is_array($arr['data'])) {
            throw new SchemaViolationException('Property \'data\' was array');
        }
    }

    /**
     * @psalm-assert array{mediaType: string|int|bool} $arr
     */
    private static function ensureMediaType(array $arr): void
    {
        if (!array_key_exists('mediaType', $arr)) {
            throw new SchemaViolationException('Property \'mediaType\' is required but was not found');
        }
        if (array_key_exists('mediaType', $arr) && is_array($arr['mediaType'])) {
            throw new SchemaViolationException('Property \'mediaType\' was array');
        }
    }
}

SourceReference.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the SourceReference message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * Points to a [Source](#io.cucumber.messages.Source) identified by `uri` and a
 * [Location](#io.cucumber.messages.Location) within that file. */
final class SourceReference implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the SourceReference with all properties
     *
     */
    public function __construct(

        public readonly ?string $uri = null,

        public readonly ?JavaMethod $javaMethod = null,

        public readonly ?JavaStackTraceElement $javaStackTraceElement = null,

        public readonly ?Location $location = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureUri($arr);
        self::ensureJavaMethod($arr);
        self::ensureJavaStackTraceElement($arr);
        self::ensureLocation($arr);

        return new self(
            isset($arr['uri']) ? (string) $arr['uri'] : null,
            isset($arr['javaMethod']) ? JavaMethod::fromArray($arr['javaMethod']) : null,
            isset($arr['javaStackTraceElement']) ? JavaStackTraceElement::fromArray($arr['javaStackTraceElement']) : null,
            isset($arr['location']) ? Location::fromArray($arr['location']) : null,
        );
    }

    /**
     * @psalm-assert array{uri?: string|int|bool} $arr
     */
    private static function ensureUri(array $arr): void
    {
        if (array_key_exists('uri', $arr) && is_array($arr['uri'])) {
            throw new SchemaViolationException('Property \'uri\' was array');
        }
    }

    /**
     * @psalm-assert array{javaMethod?: array} $arr
     */
    private static function ensureJavaMethod(array $arr): void
    {
        if (array_key_exists('javaMethod', $arr) && !is_array($arr['javaMethod'])) {
            throw new SchemaViolationException('Property \'javaMethod\' was not array');
        }
    }

    /**
     * @psalm-assert array{javaStackTraceElement?: array} $arr
     */
    private static function ensureJavaStackTraceElement(array $arr): void
    {
        if (array_key_exists('javaStackTraceElement', $arr) && !is_array($arr['javaStackTraceElement'])) {
            throw new SchemaViolationException('Property \'javaStackTraceElement\' was not array');
        }
    }

    /**
     * @psalm-assert array{location?: array} $arr
     */
    private static function ensureLocation(array $arr): void
    {
        if (array_key_exists('location', $arr) && !is_array($arr['location'])) {
            throw new SchemaViolationException('Property \'location\' was not array');
        }
    }
}

JavaMethod.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the JavaMethod message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class JavaMethod implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the JavaMethod with all properties
     *
     * @param list<string> $methodParameterTypes
     */
    public function __construct(

        public readonly string $className = '',

        public readonly string $methodName = '',

        public readonly array $methodParameterTypes = [],
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureClassName($arr);
        self::ensureMethodName($arr);
        self::ensureMethodParameterTypes($arr);

        return new self(
            (string) $arr['className'],
            (string) $arr['methodName'],
            array_values(array_map(fn (mixed $member) => (string) $member, $arr['methodParameterTypes'])),
        );
    }

    /**
     * @psalm-assert array{className: string|int|bool} $arr
     */
    private static function ensureClassName(array $arr): void
    {
        if (!array_key_exists('className', $arr)) {
            throw new SchemaViolationException('Property \'className\' is required but was not found');
        }
        if (array_key_exists('className', $arr) && is_array($arr['className'])) {
            throw new SchemaViolationException('Property \'className\' was array');
        }
    }

    /**
     * @psalm-assert array{methodName: string|int|bool} $arr
     */
    private static function ensureMethodName(array $arr): void
    {
        if (!array_key_exists('methodName', $arr)) {
            throw new SchemaViolationException('Property \'methodName\' is required but was not found');
        }
        if (array_key_exists('methodName', $arr) && is_array($arr['methodName'])) {
            throw new SchemaViolationException('Property \'methodName\' was array');
        }
    }

    /**
     * @psalm-assert array{methodParameterTypes: array} $arr
     */
    private static function ensureMethodParameterTypes(array $arr): void
    {
        if (!array_key_exists('methodParameterTypes', $arr)) {
            throw new SchemaViolationException('Property \'methodParameterTypes\' is required but was not found');
        }
        if (array_key_exists('methodParameterTypes', $arr) && !is_array($arr['methodParameterTypes'])) {
            throw new SchemaViolationException('Property \'methodParameterTypes\' was not array');
        }
    }
}

JavaStackTraceElement.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the JavaStackTraceElement message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class JavaStackTraceElement implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the JavaStackTraceElement with all properties
     *
     */
    public function __construct(

        public readonly string $className = '',

        public readonly string $fileName = '',

        public readonly string $methodName = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureClassName($arr);
        self::ensureFileName($arr);
        self::ensureMethodName($arr);

        return new self(
            (string) $arr['className'],
            (string) $arr['fileName'],
            (string) $arr['methodName'],
        );
    }

    /**
     * @psalm-assert array{className: string|int|bool} $arr
     */
    private static function ensureClassName(array $arr): void
    {
        if (!array_key_exists('className', $arr)) {
            throw new SchemaViolationException('Property \'className\' is required but was not found');
        }
        if (array_key_exists('className', $arr) && is_array($arr['className'])) {
            throw new SchemaViolationException('Property \'className\' was array');
        }
    }

    /**
     * @psalm-assert array{fileName: string|int|bool} $arr
     */
    private static function ensureFileName(array $arr): void
    {
        if (!array_key_exists('fileName', $arr)) {
            throw new SchemaViolationException('Property \'fileName\' is required but was not found');
        }
        if (array_key_exists('fileName', $arr) && is_array($arr['fileName'])) {
            throw new SchemaViolationException('Property \'fileName\' was array');
        }
    }

    /**
     * @psalm-assert array{methodName: string|int|bool} $arr
     */
    private static function ensureMethodName(array $arr): void
    {
        if (!array_key_exists('methodName', $arr)) {
            throw new SchemaViolationException('Property \'methodName\' is required but was not found');
        }
        if (array_key_exists('methodName', $arr) && is_array($arr['methodName'])) {
            throw new SchemaViolationException('Property \'methodName\' was array');
        }
    }
}

StepDefinition.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the StepDefinition message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class StepDefinition implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the StepDefinition with all properties
     *
     */
    public function __construct(

        public readonly string $id = '',

        public readonly StepDefinitionPattern $pattern = new StepDefinitionPattern(),

        public readonly SourceReference $sourceReference = new SourceReference(),
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureId($arr);
        self::ensurePattern($arr);
        self::ensureSourceReference($arr);

        return new self(
            (string) $arr['id'],
            StepDefinitionPattern::fromArray($arr['pattern']),
            SourceReference::fromArray($arr['sourceReference']),
        );
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }

    /**
     * @psalm-assert array{pattern: array} $arr
     */
    private static function ensurePattern(array $arr): void
    {
        if (!array_key_exists('pattern', $arr)) {
            throw new SchemaViolationException('Property \'pattern\' is required but was not found');
        }
        if (array_key_exists('pattern', $arr) && !is_array($arr['pattern'])) {
            throw new SchemaViolationException('Property \'pattern\' was not array');
        }
    }

    /**
     * @psalm-assert array{sourceReference: array} $arr
     */
    private static function ensureSourceReference(array $arr): void
    {
        if (!array_key_exists('sourceReference', $arr)) {
            throw new SchemaViolationException('Property \'sourceReference\' is required but was not found');
        }
        if (array_key_exists('sourceReference', $arr) && !is_array($arr['sourceReference'])) {
            throw new SchemaViolationException('Property \'sourceReference\' was not array');
        }
    }
}

StepDefinitionPattern.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the StepDefinitionPattern message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class StepDefinitionPattern implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the StepDefinitionPattern with all properties
     *
     */
    public function __construct(

        public readonly string $source = '',

        public readonly StepDefinitionPattern\Type $type = StepDefinitionPattern\Type::CUCUMBER_EXPRESSION,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureSource($arr);
        self::ensureType($arr);

        return new self(
            (string) $arr['source'],
            StepDefinitionPattern\Type::from((string) $arr['type']),
        );
    }

    /**
     * @psalm-assert array{source: string|int|bool} $arr
     */
    private static function ensureSource(array $arr): void
    {
        if (!array_key_exists('source', $arr)) {
            throw new SchemaViolationException('Property \'source\' is required but was not found');
        }
        if (array_key_exists('source', $arr) && is_array($arr['source'])) {
            throw new SchemaViolationException('Property \'source\' was array');
        }
    }

    /**
     * @psalm-assert array{type: string|int|bool} $arr
     */
    private static function ensureType(array $arr): void
    {
        if (!array_key_exists('type', $arr)) {
            throw new SchemaViolationException('Property \'type\' is required but was not found');
        }
        if (array_key_exists('type', $arr) && is_array($arr['type'])) {
            throw new SchemaViolationException('Property \'type\' was array');
        }
    }
}

TestCase.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the TestCase message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * //// TestCases
 * 
 * A `TestCase` contains a sequence of `TestStep`s. */
final class TestCase implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the TestCase with all properties
     *
     * @param list<TestStep> $testSteps
     */
    public function __construct(

        public readonly string $id = '',

        /**
         * The ID of the `Pickle` this `TestCase` is derived from.
         */
        public readonly string $pickleId = '',

        public readonly array $testSteps = [],
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureId($arr);
        self::ensurePickleId($arr);
        self::ensureTestSteps($arr);

        return new self(
            (string) $arr['id'],
            (string) $arr['pickleId'],
            array_values(array_map(fn (array $member) => TestStep::fromArray($member), $arr['testSteps'])),
        );
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }

    /**
     * @psalm-assert array{pickleId: string|int|bool} $arr
     */
    private static function ensurePickleId(array $arr): void
    {
        if (!array_key_exists('pickleId', $arr)) {
            throw new SchemaViolationException('Property \'pickleId\' is required but was not found');
        }
        if (array_key_exists('pickleId', $arr) && is_array($arr['pickleId'])) {
            throw new SchemaViolationException('Property \'pickleId\' was array');
        }
    }

    /**
     * @psalm-assert array{testSteps: array} $arr
     */
    private static function ensureTestSteps(array $arr): void
    {
        if (!array_key_exists('testSteps', $arr)) {
            throw new SchemaViolationException('Property \'testSteps\' is required but was not found');
        }
        if (array_key_exists('testSteps', $arr) && !is_array($arr['testSteps'])) {
            throw new SchemaViolationException('Property \'testSteps\' was not array');
        }
    }
}

Group.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Group message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Group implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Group with all properties
     *
     * @param list<Group> $children
     */
    public function __construct(

        public readonly array $children = [],

        public readonly ?int $start = null,

        public readonly ?string $value = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureChildren($arr);
        self::ensureStart($arr);
        self::ensureValue($arr);

        return new self(
            array_values(array_map(fn (array $member) => Group::fromArray($member), $arr['children'])),
            isset($arr['start']) ? (int) $arr['start'] : null,
            isset($arr['value']) ? (string) $arr['value'] : null,
        );
    }

    /**
     * @psalm-assert array{children: array} $arr
     */
    private static function ensureChildren(array $arr): void
    {
        if (!array_key_exists('children', $arr)) {
            throw new SchemaViolationException('Property \'children\' is required but was not found');
        }
        if (array_key_exists('children', $arr) && !is_array($arr['children'])) {
            throw new SchemaViolationException('Property \'children\' was not array');
        }
    }

    /**
     * @psalm-assert array{start?: string|int|bool} $arr
     */
    private static function ensureStart(array $arr): void
    {
        if (array_key_exists('start', $arr) && is_array($arr['start'])) {
            throw new SchemaViolationException('Property \'start\' was array');
        }
    }

    /**
     * @psalm-assert array{value?: string|int|bool} $arr
     */
    private static function ensureValue(array $arr): void
    {
        if (array_key_exists('value', $arr) && is_array($arr['value'])) {
            throw new SchemaViolationException('Property \'value\' was array');
        }
    }
}

StepMatchArgument.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the StepMatchArgument message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * Represents a single argument extracted from a step match and passed to a step definition.
 * This is used for the following purposes:
 * - Construct an argument to pass to a step definition (possibly through a parameter type transform)
 * - Highlight the matched parameter in rich formatters such as the HTML formatter
 * 
 * This message closely matches the `Argument` class in the `cucumber-expressions` library. */
final class StepMatchArgument implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the StepMatchArgument with all properties
     *
     */
    public function __construct(

        /**
         * Represents the outermost capture group of an argument. This message closely matches the
         * `Group` class in the `cucumber-expressions` library.
         */
        public readonly Group $group = new Group(),

        public readonly ?string $parameterTypeName = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureGroup($arr);
        self::ensureParameterTypeName($arr);

        return new self(
            Group::fromArray($arr['group']),
            isset($arr['parameterTypeName']) ? (string) $arr['parameterTypeName'] : null,
        );
    }

    /**
     * @psalm-assert array{group: array} $arr
     */
    private static function ensureGroup(array $arr): void
    {
        if (!array_key_exists('group', $arr)) {
            throw new SchemaViolationException('Property \'group\' is required but was not found');
        }
        if (array_key_exists('group', $arr) && !is_array($arr['group'])) {
            throw new SchemaViolationException('Property \'group\' was not array');
        }
    }

    /**
     * @psalm-assert array{parameterTypeName?: string|int|bool} $arr
     */
    private static function ensureParameterTypeName(array $arr): void
    {
        if (array_key_exists('parameterTypeName', $arr) && is_array($arr['parameterTypeName'])) {
            throw new SchemaViolationException('Property \'parameterTypeName\' was array');
        }
    }
}

StepMatchArgumentsList.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the StepMatchArgumentsList message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class StepMatchArgumentsList implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the StepMatchArgumentsList with all properties
     *
     * @param list<StepMatchArgument> $stepMatchArguments
     */
    public function __construct(

        public readonly array $stepMatchArguments = [],
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureStepMatchArguments($arr);

        return new self(
            array_values(array_map(fn (array $member) => StepMatchArgument::fromArray($member), $arr['stepMatchArguments'])),
        );
    }

    /**
     * @psalm-assert array{stepMatchArguments: array} $arr
     */
    private static function ensureStepMatchArguments(array $arr): void
    {
        if (!array_key_exists('stepMatchArguments', $arr)) {
            throw new SchemaViolationException('Property \'stepMatchArguments\' is required but was not found');
        }
        if (array_key_exists('stepMatchArguments', $arr) && !is_array($arr['stepMatchArguments'])) {
            throw new SchemaViolationException('Property \'stepMatchArguments\' was not array');
        }
    }
}

TestStep.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the TestStep message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 * A `TestStep` is derived from either a `PickleStep`
 * combined with a `StepDefinition`, or from a `Hook`. */
final class TestStep implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the TestStep with all properties
     *
     * @param ?list<string> $stepDefinitionIds
     * @param ?list<StepMatchArgumentsList> $stepMatchArgumentsLists
     */
    public function __construct(

        /**
         * Pointer to the `Hook` (if derived from a Hook)
         */
        public readonly ?string $hookId = null,

        public readonly string $id = '',

        /**
         * Pointer to the `PickleStep` (if derived from a `PickleStep`)
         */
        public readonly ?string $pickleStepId = null,

        /**
         * Pointer to all the matching `StepDefinition`s (if derived from a `PickleStep`)
         */
        public readonly ?array $stepDefinitionIds = null,

        /**
         * A list of list of StepMatchArgument (if derived from a `PickleStep`).
         * Each element represents a matching step definition. A size of 0 means `UNDEFINED`,
         * and a size of 2+ means `AMBIGUOUS`
         */
        public readonly ?array $stepMatchArgumentsLists = null,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureHookId($arr);
        self::ensureId($arr);
        self::ensurePickleStepId($arr);
        self::ensureStepDefinitionIds($arr);
        self::ensureStepMatchArgumentsLists($arr);

        return new self(
            isset($arr['hookId']) ? (string) $arr['hookId'] : null,
            (string) $arr['id'],
            isset($arr['pickleStepId']) ? (string) $arr['pickleStepId'] : null,
            isset($arr['stepDefinitionIds']) ? array_values(array_map(fn (mixed $member) => (string) $member, $arr['stepDefinitionIds'])) : null,
            isset($arr['stepMatchArgumentsLists']) ? array_values(array_map(fn (array $member) => StepMatchArgumentsList::fromArray($member), $arr['stepMatchArgumentsLists'])) : null,
        );
    }

    /**
     * @psalm-assert array{hookId?: string|int|bool} $arr
     */
    private static function ensureHookId(array $arr): void
    {
        if (array_key_exists('hookId', $arr) && is_array($arr['hookId'])) {
            throw new SchemaViolationException('Property \'hookId\' was array');
        }
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }

    /**
     * @psalm-assert array{pickleStepId?: string|int|bool} $arr
     */
    private static function ensurePickleStepId(array $arr): void
    {
        if (array_key_exists('pickleStepId', $arr) && is_array($arr['pickleStepId'])) {
            throw new SchemaViolationException('Property \'pickleStepId\' was array');
        }
    }

    /**
     * @psalm-assert array{stepDefinitionIds?: array} $arr
     */
    private static function ensureStepDefinitionIds(array $arr): void
    {
        if (array_key_exists('stepDefinitionIds', $arr) && !is_array($arr['stepDefinitionIds'])) {
            throw new SchemaViolationException('Property \'stepDefinitionIds\' was not array');
        }
    }

    /**
     * @psalm-assert array{stepMatchArgumentsLists?: array} $arr
     */
    private static function ensureStepMatchArgumentsLists(array $arr): void
    {
        if (array_key_exists('stepMatchArgumentsLists', $arr) && !is_array($arr['stepMatchArgumentsLists'])) {
            throw new SchemaViolationException('Property \'stepMatchArgumentsLists\' was not array');
        }
    }
}

TestCaseFinished.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the TestCaseFinished message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestCaseFinished implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the TestCaseFinished with all properties
     *
     */
    public function __construct(

        public readonly string $testCaseStartedId = '',

        public readonly Timestamp $timestamp = new Timestamp(),

        public readonly bool $willBeRetried = false,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureTestCaseStartedId($arr);
        self::ensureTimestamp($arr);
        self::ensureWillBeRetried($arr);

        return new self(
            (string) $arr['testCaseStartedId'],
            Timestamp::fromArray($arr['timestamp']),
            (bool) $arr['willBeRetried'],
        );
    }

    /**
     * @psalm-assert array{testCaseStartedId: string|int|bool} $arr
     */
    private static function ensureTestCaseStartedId(array $arr): void
    {
        if (!array_key_exists('testCaseStartedId', $arr)) {
            throw new SchemaViolationException('Property \'testCaseStartedId\' is required but was not found');
        }
        if (array_key_exists('testCaseStartedId', $arr) && is_array($arr['testCaseStartedId'])) {
            throw new SchemaViolationException('Property \'testCaseStartedId\' was array');
        }
    }

    /**
     * @psalm-assert array{timestamp: array} $arr
     */
    private static function ensureTimestamp(array $arr): void
    {
        if (!array_key_exists('timestamp', $arr)) {
            throw new SchemaViolationException('Property \'timestamp\' is required but was not found');
        }
        if (array_key_exists('timestamp', $arr) && !is_array($arr['timestamp'])) {
            throw new SchemaViolationException('Property \'timestamp\' was not array');
        }
    }

    /**
     * @psalm-assert array{willBeRetried: string|int|bool} $arr
     */
    private static function ensureWillBeRetried(array $arr): void
    {
        if (!array_key_exists('willBeRetried', $arr)) {
            throw new SchemaViolationException('Property \'willBeRetried\' is required but was not found');
        }
        if (array_key_exists('willBeRetried', $arr) && is_array($arr['willBeRetried'])) {
            throw new SchemaViolationException('Property \'willBeRetried\' was array');
        }
    }
}

TestCaseStarted.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the TestCaseStarted message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestCaseStarted implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the TestCaseStarted with all properties
     *
     */
    public function __construct(

        /**
         * The first attempt should have value 0, and for each retry the value
         * should increase by 1.
         */
        public readonly int $attempt = 0,

        /**
         * Because a `TestCase` can be run multiple times (in case of a retry),
         * we use this field to group messages relating to the same attempt.
         */
        public readonly string $id = '',

        public readonly string $testCaseId = '',

        public readonly Timestamp $timestamp = new Timestamp(),
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureAttempt($arr);
        self::ensureId($arr);
        self::ensureTestCaseId($arr);
        self::ensureTimestamp($arr);

        return new self(
            (int) $arr['attempt'],
            (string) $arr['id'],
            (string) $arr['testCaseId'],
            Timestamp::fromArray($arr['timestamp']),
        );
    }

    /**
     * @psalm-assert array{attempt: string|int|bool} $arr
     */
    private static function ensureAttempt(array $arr): void
    {
        if (!array_key_exists('attempt', $arr)) {
            throw new SchemaViolationException('Property \'attempt\' is required but was not found');
        }
        if (array_key_exists('attempt', $arr) && is_array($arr['attempt'])) {
            throw new SchemaViolationException('Property \'attempt\' was array');
        }
    }

    /**
     * @psalm-assert array{id: string|int|bool} $arr
     */
    private static function ensureId(array $arr): void
    {
        if (!array_key_exists('id', $arr)) {
            throw new SchemaViolationException('Property \'id\' is required but was not found');
        }
        if (array_key_exists('id', $arr) && is_array($arr['id'])) {
            throw new SchemaViolationException('Property \'id\' was array');
        }
    }

    /**
     * @psalm-assert array{testCaseId: string|int|bool} $arr
     */
    private static function ensureTestCaseId(array $arr): void
    {
        if (!array_key_exists('testCaseId', $arr)) {
            throw new SchemaViolationException('Property \'testCaseId\' is required but was not found');
        }
        if (array_key_exists('testCaseId', $arr) && is_array($arr['testCaseId'])) {
            throw new SchemaViolationException('Property \'testCaseId\' was array');
        }
    }

    /**
     * @psalm-assert array{timestamp: array} $arr
     */
    private static function ensureTimestamp(array $arr): void
    {
        if (!array_key_exists('timestamp', $arr)) {
            throw new SchemaViolationException('Property \'timestamp\' is required but was not found');
        }
        if (array_key_exists('timestamp', $arr) && !is_array($arr['timestamp'])) {
            throw new SchemaViolationException('Property \'timestamp\' was not array');
        }
    }
}

TestRunFinished.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the TestRunFinished message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestRunFinished implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the TestRunFinished with all properties
     *
     */
    public function __construct(

        /**
         * Error message. Can be a stack trace from a failed `BeforeAll` or `AfterAll`.
         * If there are undefined parameter types, the message is simply
         * "The following parameter type(s() are not defined: xxx, yyy".
         * The independent `UndefinedParameterType` messages can be used to generate
         * snippets for those parameter types.
         */
        public readonly ?string $message = null,

        /**
         * success = StrictModeEnabled ? (failed_count == 0 && ambiguous_count == 0 && undefined_count == 0 && pending_count == 0) : (failed_count == 0 && ambiguous_count == 0)
         */
        public readonly bool $success = false,

        /**
         * Timestamp when the TestRun is finished
         */
        public readonly Timestamp $timestamp = new Timestamp(),
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureMessage($arr);
        self::ensureSuccess($arr);
        self::ensureTimestamp($arr);

        return new self(
            isset($arr['message']) ? (string) $arr['message'] : null,
            (bool) $arr['success'],
            Timestamp::fromArray($arr['timestamp']),
        );
    }

    /**
     * @psalm-assert array{message?: string|int|bool} $arr
     */
    private static function ensureMessage(array $arr): void
    {
        if (array_key_exists('message', $arr) && is_array($arr['message'])) {
            throw new SchemaViolationException('Property \'message\' was array');
        }
    }

    /**
     * @psalm-assert array{success: string|int|bool} $arr
     */
    private static function ensureSuccess(array $arr): void
    {
        if (!array_key_exists('success', $arr)) {
            throw new SchemaViolationException('Property \'success\' is required but was not found');
        }
        if (array_key_exists('success', $arr) && is_array($arr['success'])) {
            throw new SchemaViolationException('Property \'success\' was array');
        }
    }

    /**
     * @psalm-assert array{timestamp: array} $arr
     */
    private static function ensureTimestamp(array $arr): void
    {
        if (!array_key_exists('timestamp', $arr)) {
            throw new SchemaViolationException('Property \'timestamp\' is required but was not found');
        }
        if (array_key_exists('timestamp', $arr) && !is_array($arr['timestamp'])) {
            throw new SchemaViolationException('Property \'timestamp\' was not array');
        }
    }
}

TestRunStarted.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the TestRunStarted message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestRunStarted implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the TestRunStarted with all properties
     *
     */
    public function __construct(

        public readonly Timestamp $timestamp = new Timestamp(),
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureTimestamp($arr);

        return new self(
            Timestamp::fromArray($arr['timestamp']),
        );
    }

    /**
     * @psalm-assert array{timestamp: array} $arr
     */
    private static function ensureTimestamp(array $arr): void
    {
        if (!array_key_exists('timestamp', $arr)) {
            throw new SchemaViolationException('Property \'timestamp\' is required but was not found');
        }
        if (array_key_exists('timestamp', $arr) && !is_array($arr['timestamp'])) {
            throw new SchemaViolationException('Property \'timestamp\' was not array');
        }
    }
}

TestStepFinished.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the TestStepFinished message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestStepFinished implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the TestStepFinished with all properties
     *
     */
    public function __construct(

        public readonly string $testCaseStartedId = '',

        public readonly string $testStepId = '',

        public readonly TestStepResult $testStepResult = new TestStepResult(),

        public readonly Timestamp $timestamp = new Timestamp(),
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureTestCaseStartedId($arr);
        self::ensureTestStepId($arr);
        self::ensureTestStepResult($arr);
        self::ensureTimestamp($arr);

        return new self(
            (string) $arr['testCaseStartedId'],
            (string) $arr['testStepId'],
            TestStepResult::fromArray($arr['testStepResult']),
            Timestamp::fromArray($arr['timestamp']),
        );
    }

    /**
     * @psalm-assert array{testCaseStartedId: string|int|bool} $arr
     */
    private static function ensureTestCaseStartedId(array $arr): void
    {
        if (!array_key_exists('testCaseStartedId', $arr)) {
            throw new SchemaViolationException('Property \'testCaseStartedId\' is required but was not found');
        }
        if (array_key_exists('testCaseStartedId', $arr) && is_array($arr['testCaseStartedId'])) {
            throw new SchemaViolationException('Property \'testCaseStartedId\' was array');
        }
    }

    /**
     * @psalm-assert array{testStepId: string|int|bool} $arr
     */
    private static function ensureTestStepId(array $arr): void
    {
        if (!array_key_exists('testStepId', $arr)) {
            throw new SchemaViolationException('Property \'testStepId\' is required but was not found');
        }
        if (array_key_exists('testStepId', $arr) && is_array($arr['testStepId'])) {
            throw new SchemaViolationException('Property \'testStepId\' was array');
        }
    }

    /**
     * @psalm-assert array{testStepResult: array} $arr
     */
    private static function ensureTestStepResult(array $arr): void
    {
        if (!array_key_exists('testStepResult', $arr)) {
            throw new SchemaViolationException('Property \'testStepResult\' is required but was not found');
        }
        if (array_key_exists('testStepResult', $arr) && !is_array($arr['testStepResult'])) {
            throw new SchemaViolationException('Property \'testStepResult\' was not array');
        }
    }

    /**
     * @psalm-assert array{timestamp: array} $arr
     */
    private static function ensureTimestamp(array $arr): void
    {
        if (!array_key_exists('timestamp', $arr)) {
            throw new SchemaViolationException('Property \'timestamp\' is required but was not found');
        }
        if (array_key_exists('timestamp', $arr) && !is_array($arr['timestamp'])) {
            throw new SchemaViolationException('Property \'timestamp\' was not array');
        }
    }
}

TestStepResult.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the TestStepResult message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestStepResult implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the TestStepResult with all properties
     *
     */
    public function __construct(

        public readonly Duration $duration = new Duration(),

        public readonly ?string $message = null,

        public readonly TestStepResult\Status $status = TestStepResult\Status::UNKNOWN,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureDuration($arr);
        self::ensureMessage($arr);
        self::ensureStatus($arr);

        return new self(
            Duration::fromArray($arr['duration']),
            isset($arr['message']) ? (string) $arr['message'] : null,
            TestStepResult\Status::from((string) $arr['status']),
        );
    }

    /**
     * @psalm-assert array{duration: array} $arr
     */
    private static function ensureDuration(array $arr): void
    {
        if (!array_key_exists('duration', $arr)) {
            throw new SchemaViolationException('Property \'duration\' is required but was not found');
        }
        if (array_key_exists('duration', $arr) && !is_array($arr['duration'])) {
            throw new SchemaViolationException('Property \'duration\' was not array');
        }
    }

    /**
     * @psalm-assert array{message?: string|int|bool} $arr
     */
    private static function ensureMessage(array $arr): void
    {
        if (array_key_exists('message', $arr) && is_array($arr['message'])) {
            throw new SchemaViolationException('Property \'message\' was array');
        }
    }

    /**
     * @psalm-assert array{status: string|int|bool} $arr
     */
    private static function ensureStatus(array $arr): void
    {
        if (!array_key_exists('status', $arr)) {
            throw new SchemaViolationException('Property \'status\' is required but was not found');
        }
        if (array_key_exists('status', $arr) && is_array($arr['status'])) {
            throw new SchemaViolationException('Property \'status\' was array');
        }
    }
}

TestStepStarted.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the TestStepStarted message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class TestStepStarted implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the TestStepStarted with all properties
     *
     */
    public function __construct(

        public readonly string $testCaseStartedId = '',

        public readonly string $testStepId = '',

        public readonly Timestamp $timestamp = new Timestamp(),
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureTestCaseStartedId($arr);
        self::ensureTestStepId($arr);
        self::ensureTimestamp($arr);

        return new self(
            (string) $arr['testCaseStartedId'],
            (string) $arr['testStepId'],
            Timestamp::fromArray($arr['timestamp']),
        );
    }

    /**
     * @psalm-assert array{testCaseStartedId: string|int|bool} $arr
     */
    private static function ensureTestCaseStartedId(array $arr): void
    {
        if (!array_key_exists('testCaseStartedId', $arr)) {
            throw new SchemaViolationException('Property \'testCaseStartedId\' is required but was not found');
        }
        if (array_key_exists('testCaseStartedId', $arr) && is_array($arr['testCaseStartedId'])) {
            throw new SchemaViolationException('Property \'testCaseStartedId\' was array');
        }
    }

    /**
     * @psalm-assert array{testStepId: string|int|bool} $arr
     */
    private static function ensureTestStepId(array $arr): void
    {
        if (!array_key_exists('testStepId', $arr)) {
            throw new SchemaViolationException('Property \'testStepId\' is required but was not found');
        }
        if (array_key_exists('testStepId', $arr) && is_array($arr['testStepId'])) {
            throw new SchemaViolationException('Property \'testStepId\' was array');
        }
    }

    /**
     * @psalm-assert array{timestamp: array} $arr
     */
    private static function ensureTimestamp(array $arr): void
    {
        if (!array_key_exists('timestamp', $arr)) {
            throw new SchemaViolationException('Property \'timestamp\' is required but was not found');
        }
        if (array_key_exists('timestamp', $arr) && !is_array($arr['timestamp'])) {
            throw new SchemaViolationException('Property \'timestamp\' was not array');
        }
    }
}

Timestamp.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the Timestamp message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class Timestamp implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the Timestamp with all properties
     *
     */
    public function __construct(

        /**
         * Represents seconds of UTC time since Unix epoch
         * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
         * 9999-12-31T23:59:59Z inclusive.
         */
        public readonly int $seconds = 0,

        /**
         * Non-negative fractions of a second at nanosecond resolution. Negative
         * second values with fractions must still have non-negative nanos values
         * that count forward in time. Must be from 0 to 999,999,999
         * inclusive.
         */
        public readonly int $nanos = 0,
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureSeconds($arr);
        self::ensureNanos($arr);

        return new self(
            (int) $arr['seconds'],
            (int) $arr['nanos'],
        );
    }

    /**
     * @psalm-assert array{seconds: string|int|bool} $arr
     */
    private static function ensureSeconds(array $arr): void
    {
        if (!array_key_exists('seconds', $arr)) {
            throw new SchemaViolationException('Property \'seconds\' is required but was not found');
        }
        if (array_key_exists('seconds', $arr) && is_array($arr['seconds'])) {
            throw new SchemaViolationException('Property \'seconds\' was array');
        }
    }

    /**
     * @psalm-assert array{nanos: string|int|bool} $arr
     */
    private static function ensureNanos(array $arr): void
    {
        if (!array_key_exists('nanos', $arr)) {
            throw new SchemaViolationException('Property \'nanos\' is required but was not found');
        }
        if (array_key_exists('nanos', $arr) && is_array($arr['nanos'])) {
            throw new SchemaViolationException('Property \'nanos\' was array');
        }
    }
}

UndefinedParameterType.php
<?php

declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages;

use JsonSerializable;
use Cucumber\Messages\DecodingException\SchemaViolationException;
/**
 * Represents the UndefinedParameterType message in Cucumber's message protocol
 * @see https://github.com/cucumber/common/tree/main/messages#readme
 *
 */
final class UndefinedParameterType implements JsonSerializable
{
    use JsonEncodingTrait;

    /**
     * Construct the UndefinedParameterType with all properties
     *
     */
    public function __construct(

        public readonly string $expression = '',

        public readonly string $name = '',
    ) {
    }

    /**
     * @throws SchemaViolationException
     *
     * @internal
     */
    public static function fromArray(array $arr): self
    {
        self::ensureExpression($arr);
        self::ensureName($arr);

        return new self(
            (string) $arr['expression'],
            (string) $arr['name'],
        );
    }

    /**
     * @psalm-assert array{expression: string|int|bool} $arr
     */
    private static function ensureExpression(array $arr): void
    {
        if (!array_key_exists('expression', $arr)) {
            throw new SchemaViolationException('Property \'expression\' is required but was not found');
        }
        if (array_key_exists('expression', $arr) && is_array($arr['expression'])) {
            throw new SchemaViolationException('Property \'expression\' was array');
        }
    }

    /**
     * @psalm-assert array{name: string|int|bool} $arr
     */
    private static function ensureName(array $arr): void
    {
        if (!array_key_exists('name', $arr)) {
            throw new SchemaViolationException('Property \'name\' is required but was not found');
        }
        if (array_key_exists('name', $arr) && is_array($arr['name'])) {
            throw new SchemaViolationException('Property \'name\' was array');
        }
    }
}


Attachment/ContentEncoding.php
<?php declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages\Attachment;

enum ContentEncoding: string
{
  case IDENTITY = 'IDENTITY';
  case BASE64 = 'BASE64';
}
PickleStep/Type.php
<?php declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages\PickleStep;

enum Type: string
{
  case UNKNOWN = 'Unknown';
  case CONTEXT = 'Context';
  case ACTION = 'Action';
  case OUTCOME = 'Outcome';
}
Source/MediaType.php
<?php declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages\Source;

enum MediaType: string
{
  case TEXT_X_CUCUMBER_GHERKIN_PLAIN = 'text/x.cucumber.gherkin+plain';
  case TEXT_X_CUCUMBER_GHERKIN_MARKDOWN = 'text/x.cucumber.gherkin+markdown';
}
StepDefinitionPattern/Type.php
<?php declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages\StepDefinitionPattern;

enum Type: string
{
  case CUCUMBER_EXPRESSION = 'CUCUMBER_EXPRESSION';
  case REGULAR_EXPRESSION = 'REGULAR_EXPRESSION';
}
Step/KeywordType.php
<?php declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages\Step;

enum KeywordType: string
{
  case UNKNOWN = 'Unknown';
  case CONTEXT = 'Context';
  case ACTION = 'Action';
  case OUTCOME = 'Outcome';
  case CONJUNCTION = 'Conjunction';
}
TestStepResult/Status.php
<?php declare(strict_types=1);

/**
 * This code was auto-generated by {this script}[https://github.com/cucumber/common/blob/main/messages/jsonschema/scripts/codegen.rb]
 */

namespace Cucumber\Messages\TestStepResult;

enum Status: string
{
  case UNKNOWN = 'UNKNOWN';
  case PASSED = 'PASSED';
  case SKIPPED = 'SKIPPED';
  case PENDING = 'PENDING';
  case UNDEFINED = 'UNDEFINED';
  case AMBIGUOUS = 'AMBIGUOUS';
  case FAILED = 'FAILED';
}

